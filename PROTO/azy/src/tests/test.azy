/*
 * Copyright 2010 Mike Blumenkrantz <mike@zentific.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 2.1 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Set the namespace to T: this prefixes all generated functions and types with 'T_'
 */
namespace T;

/**
 * define two #Eina_Error codes with values 1, 2
 * set their strings to the value between and including the braces
 * semicolon required, empty error string permitted between braces
 */
error ERR1 = 1 { sup this is an error };
error ERR2 = 2 { chea dawg this is also an error };
error ERR3 = 3; /* look ma, no message! */

/**
 * Create typedef struct named Struct (T_Struct in C)
 */
struct Struct
{
   /** string member named v_string; strings are stringshared
    * const char*
    */
   string v_string;
};

/**
 * Create typedef struct named AllArrays (T_AllArrays in C)
 */
struct AllArrays
{
   array<string>  a_string; /**< array of stringshared strings */
   array<time>    a_time; /**< array of stringshared time strings */
   array<base64>  a_base64; /**< array of stringshared base64-encoded strings */
   array<int>     a_int; /**< array of ints */
   array<boolean> a_boolean; /**< array of Eina_Bools */
   array<double>  a_double; /**< array of doubles */
   array<Struct>  a_struct; /**< array of Struct objects (T_Structs in C) */
   array<array<string>> aa_string; /**< array of arrays of stringshared strings */
   array<array<array<string>>> aaa_string; /** array of arrays of arrays of stringshared strings */
};

/**
 * Create typedef struct named AllTypes (T_AllTypes in C)
 */
struct AllTypes
{
   string v_string; /**< stringshared string */
   time      v_time; /**< stringshared time string */
   base64    v_base64; /**< stringshared base64-encoded string */
   int       v_int; /**< int */
   boolean   v_boolean; /**< Eina_Bool */
   double    v_double; /**< double */
   Struct    v_struct; /**< Struct object (T_Struct in C) */
   AllArrays v_arrays; /**< AllArrays object (T_AllArrays in C) */
};

/**
 * Create a module named 'Test1' which can contain methods, structs, errors, etc
 */
Azy_Module Test1
{
   /** <% %> are {} for .azy files and are placed around sections of modules
    * this first section is the includes section which is placed at the top of the
    * generated c code files, so all headers required by the server methods in this
    * module must be included here
    */
   <%
    #include <stdio.h>
    #include <string.h>
   %>

   /**
    * define some module-specific errors which are only used
    * within this module
    */
   error NOTHING = 2 { error messageeeeeeeeeeeeeeee };
   error NO_DATA = 5 { and another errrorrrrrrrrrrrrrrr woooo };

   /**
    * this is a method description for method "getAll" in module Test1
    * with namespace T.  to call this method externally, you would use the string
    * "T_Test1.getAll" in your rpc call.
    * Note, however, that since we are in the .azy file, we can skip using any
    * namespacing IN THE METHOD PROTOTYPE ONLY and just use the types themselves
    * Note also that getAll(void) is not allowed.
    */
   AllTypes getAll()
   <%
   /** begin method code
    * NOTE: if you are only writing client code, you can leave the method code blank!
    */
     char *buf;
     /** the below line can be uncommented so you can see where it gets called
      * from when the method is called
      */
  //   printf("%s:%s:%d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
     retval = T_AllTypes_new(); /**< We are in C here since it is between < % % >
                                     * This means we must use all namespaces. since this
                                     * is a globally accessible struct, it must be prefixed with T_
                                     * Note that using < % % > without spaces in a comment
                                     * will result in a parser error (FIXME).
                                     */
     retval->v_string = eina_stringshare_add("Hi!");
     retval->v_time = eina_stringshare_add("2010-11-01");
     buf = azy_base64_encode("Hi all!", sizeof("Hi all!"));
     retval->v_base64 = eina_stringshare_add(buf);
     free(buf);
     retval->v_int = 5645;
     retval->v_boolean = EINA_FALSE;
     retval->v_double = 123.123e-3;
     retval->v_struct = T_Struct_new();
     retval->v_struct->v_string = eina_stringshare_add("some str");
     retval->v_arrays = T_AllArrays_new(); /**< Again, we're still in C so we must use the T namespace */

     /** The 3 lines below this demonstrate how to use generated copy and eq functions */
     T_AllTypes *orig = retval;
     retval = T_AllTypes_copy(retval); /**< copying is always nullsafe */
     if (!T_AllTypes_eq(retval, orig)) /**< as is eq */
       printf("Error! Copying failed!\n");
     T_AllTypes_free(orig); /**< as is free */
     return retval; /**< as the method prototype describes, this must return a AllTypes (T_Alltypes in C)
                      * struct, so we return one here
                      * this line is 100% optional, as the parser automatically
                      * inserts 'return retval;' at the bottom of every generated function.
                      * if you are returning a variable that is not named retval, however,
                      * you will need an explicit return.
                      */
   /** end method code */
   %>

   /** Method "T_Test1.getAllArrays"
    * takes no params and returns an AllArrays struct
    */
   AllArrays getAllArrays()
   <%
     int i;

     /** method-specific macro */
     #define ADD(a, val) retval->a = eina_list_append(retval->a, val)

    /** another testing printf */
    // printf("%s:%s:%d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);

     retval = T_AllArrays_new(); /** in C here, so use namespace */

     for (i = 0; i < 5; i++)
       /** using macros in a method call! */
       ADD(a_string, eina_stringshare_printf("str%d", i));

     ADD(a_string, eina_stringshare_add("&#10;test<\xc4\x8d\xc5\x99\xc5\xa1"));

     for (i = 1; i < 10; i++)
       ADD(a_time, eina_stringshare_printf("2006-04-%02d", i));

     for (i = 0; i < 2; i++)
       {
          const char *buf;
          char *b64;
          /** base64 encoding...in a method! */
          buf = eina_stringshare_printf("BBBBBBBBBBBBBBBBBLOOOOOB%d", i);
          b64 = azy_base64_encode(buf, eina_stringshare_strlen(buf));
          eina_stringshare_del(buf);
          ADD(a_base64, eina_stringshare_add(b64));
          free(b64);
       }

     for (i = 0; i < 10; i++)
       ADD(a_int, (void *)&i);

     for (i = 0; i < 10; i++)
       {
          int x = i % 2;
          ADD(a_boolean, (void *)&x);
       }

     //    for (i = 0; i < 5; i++)
     //      ADD(a_double, (void *)(double)(i * 1.11e-3));
     for (i = 0; i < 2; i++)
       {
          T_Struct *s = T_Struct_new();
          /** Yes, I know this is lazy and not checking for alloc failures,
           * but it's an example!
           */
          s->v_string = eina_stringshare_printf("struct val %d", i);
          ADD(a_struct, s);
       }

     for (i = 0; i < 2; i++)
       {
          Eina_List *a = NULL;
          int j;

          for (j = 0; j < 10; j++)
            a = eina_list_append(a, eina_stringshare_printf("[%d %d]", i, j));

          ADD(aa_string, a);
       }

     for (i = 0; i < 2; i++)
       {
          Eina_List *a = NULL;
          int j;

          for (j = 0; j < 10; j++)
            {
               Eina_List *b = NULL;
               int k;

               for (k = 0; k < 3; k++)
                 b = eina_list_append(b, eina_stringshare_printf("[%d %d %d]", i, j, k));

               a = eina_list_append(a, b);
            }

          ADD(aaa_string, a);
       }

          #undef ADD

     /** copying again! and eq! */
     T_AllArrays *orig = retval;
     retval = T_AllArrays_copy(retval);
     if (!T_AllArrays_eq(orig, retval))
       printf("Error! Copying failed!\n");
     T_AllArrays_free(orig);
   %> /**< note the lack of return statement here */

   boolean setAll(AllTypes all)
   <%
     printf("%s:%s:%d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
     /** demonstrate generated isnull usage */
     if (T_AllTypes_isnull(all))
       printf("All members of input are null!\n");
     return EINA_TRUE; /**< explicitly returning true */
   %>

   array<string> getBigArray()
   <%
     int i;

     for (i = 0; i < 5000; i++)
       /** retval exists, is the correct return type, and is always null to begin with, so this is safe */
       retval = eina_list_append(retval, eina_stringshare_printf("user.bob%d@zentific.com", i));
     /** automatic return again */
   %>

   boolean putBigArray(array<string> arr)
   <%
#if 0
     Array_string_print(">>>", 0, arr); /**< demonstrate generated print function; prefix all lines
                                          * with '>>>'
                                          */
#endif
     return EINA_TRUE;
   %>

   /** the __attrs__ section determines the struct that is passed to every method
    * and can be thought of as the data associated with the module.  calling
    * azy_server_module_data_get(module) in any function will return this data as a void*.
    * there is also a convenience macro generated to automatically cast the data to the correct
    * type: here, using these namespaces, the macro is T_Test1_module_data_get()
    */
   __attrs__
   <%
     const char *username; /**< module data contains this member which can be accessed
                             * like regular struct data with ->username
                             */
   %>

   /** the __init__ section is called one time upon the module being loaded.
    * The only param passed to it is (Azy_Server_Module module) which can be
    * used to get the private data struct.  no network information is available yet as the
    * call has not actually begun.
    * init functions must explicitly return EINA_FALSE to cancel initialization, as the default is
    * to return EINA_TRUE.
    */
   __init__
   <%
 //    printf("%s:%s:%d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
   %>

   /** the __init__ section is called one time upon the module being loaded.
    * The only param passed to it is (Azy_Server_Module module) which can be
    * used to get the private data struct.  no network information is available yet as the
    * call has not actually begun.
    * shutdown functions return no value.
    */
   __shutdown__
   <%
  //   printf("%s:%s:%d\n", __FILE__, __PRETTY_FUNCTION__, __LINE__);
   %>

   /** __pre__ is called just before the method call itself, and network information
    * can be retrieved using azy_server_module_net_get.  the private data struct also
    * exists here. this is generally where any sort of authorization (login) or session
    * validating functions should be called.
    * to prevent the call from occurring, explicitly return EINA_FALSE.
    */
   __pre__
   <%
    //printf("Pre-call!\n");
   %>

   /** __post__ is called just after the method call itself, and network information
    * can still be retrieved using azy_server_module_net_get.  the private data struct also
    * exists here.
    * to prevent the call from occurring, explicitly return EINA_FALSE.
    */
   __post__
   <%
    //printf("Post-call!\n");
   %>

   /** __fallback__ is the method that is called if an undefined method is called by a client.
    * it has module and content parameters just like a regular method call, but it returns Eina_Bool
    * for success.
    */
   __fallback__
   <%
     printf("Unknown method called %s!\n", azy_content_method_full_get(content));
     azy_content_retval_set(content, azy_value_bool_new(EINA_TRUE)); /**< retval must be explicitly set here */
     return EINA_TRUE; /**< fallback will use the default handler if #EINA_FALSE is returned;
                         * the default handler does almost exactly this
                         */
   %>

   /** __download__ is the function called for HTTP GET requests, and is how you can make azy
    * behave like a web server.  simply use azy_server_client_send on the #Azy_Server_Module's
    * #Azy_Net object and return EINA_TRUE to send the data that you want.  #EINA_FALSE will
    * send an HTTP 501 error.
    */
   __download__
   <%
     const char *path; /**< The http uri requested */
     const char *username;
     const char *password;

     /** net is the #Azy_Net object of the client and is automatically set
      * for the download and upload functions
      */
     path = azy_net_uri_get(net);
     if (!azy_net_auth_get(net, &username, &password))
       {
          azy_net_code_set(net, 401);
          azy_net_header_set(net, "Content-Type", "text/plain");
          azy_net_header_set(net, "WWW-Authenticate", "Basic realm=\"Azy Testsuite\"");
          azy_server_client_send(net, (unsigned char *)"Authentication Required", 23);
          return EINA_TRUE;
       }

     printf("Authorized: '%s' '%s'\n", username, password);
     eina_stringshare_del(username);
     eina_stringshare_del(password);

     if (1) /**< this if could compare username/password against correct values */
       {
          azy_net_code_set(net, 200);
          azy_net_header_set(net, "Content-Type", "text/plain");
          azy_server_client_send(net, (unsigned char *)"Crap\n", 5);
          return EINA_TRUE;
       }
     else
       {
          Eina_Strbuf *response = eina_strbuf_new();
          eina_strbuf_append_printf(response, "<html><head><title>401 Not Authorized</title></head><body><h1>401 Not Authorized</h1><p>You are not authorized to download %s</p></body></html>", path);

          azy_net_code_set(net, 401);
          azy_net_header_set(net, "Content-Type", "text/html");
          azy_server_client_send(net, (unsigned char *)eina_strbuf_string_get(response), eina_strbuf_length_get(response));

          eina_strbuf_free(response);
          return EINA_TRUE;
       }

   %>

   /** __upload__ is the function called for HTTP PUT requests, and is how you can make azy
    * behave like an ftp server.  #EINA_FALSE will send an HTTP 501 error.
    * FIXME: document better
    */
/*
        __upload__
        <%
        //	size_t read_bytes;
        //	const char* path = azy_net_resource_get(net);
                const char* username;
                const char* password;

                if (!azy_net_basic_auth_get(net, &username, &password))
                {
                        azy_net_code_set(net, 401);
                        azy_net_header_set(net, "Content-Type", "text/plain");
                        azy_net_header_set(net, "WWW-Authenticate", "Basic realm=\"Azy Testsuite\"");
                        azy_server_client_send(net, (unsigned char*)"Authentication Required", -1);
                        return EINA_TRUE;
                }

                printf("Authorized: '%s' '%s'\n", username, password);
                eina_stringshare_del(username);
                eina_stringshare_del(password);

                Eina_Strbuf* data = azy_net_read_all(net);
                printf("%s\n", eina_strbuf_string_get(data));
                eina_strbuf_free(data);

                azy_net_code_set(net, 200);
                azy_net_header_set(net, "Content-Type", "text/plain");
                azy_server_client_send(net, (unsigned char*)"Crap\n", -1);
                return EINA_TRUE;
        %>
 */
}

/**
 * separate module, new sub-namespace
 */
Azy_Module Test2
{
   <%
#include <stdio.h>
#include <string.h>
   %>

   __attrs__
   <%
     const char *username;
     const char *password;
   %>

   __init__
   <%
     Azy_Net *net = azy_server_module_net_get(module);
     printf("Init AUTH Servlet!\n");
     printf("Accepted connection from: %s\n", azy_net_ip_get(net));
   %>

   __shutdown__
   <%
     printf("Shutdown AUTH Servlet!\n");
   %>

   boolean auth(string name,
                string password)
   <%
     /** really, the manual retrieval of the private data is unnecessary as it will
      * always be stored in data_ prior to this code being called, as seen here
      */
     printf("AUTH-PRE:  %s, %s\n", data_->username, data_->password);
     data_->username = eina_stringshare_ref(name); /**< all params are freed immediately following the call,
                                                     * so they must be copied
                                                     * all strings will always be stringshared, remember
                                                     */
     data_->password = eina_stringshare_ref(password);
     printf("AUTH-POST: %s, %s\n", data_->username, data_->password);
     return EINA_TRUE;
   %>

   string getUsername()
   <%
     return eina_stringshare_ref(data_->username);
   %>
}

/** slightly more complicated example that uses mysql
 * to do a trivial database query on an rpc call
 */
Azy_Module SQL
{
   <%
     #include <mysql/mysql.h>
   %>

   __init__
   <%
      /** make sure to init the library for the module's use.
       * this should actually be done in the server's code (not in the .azy at all),
       * but it's an example. so we init for every load. deal with it.
       */
      mysql_library_init(0, NULL, NULL);
   %>

   __shutdown__
   <%
      /** clean up on unload */
      mysql_library_end();
   %>

   __attrs__
   <%
      MYSQL *m; /**< add a mysql database handle to the private struct */
   %>

   boolean test() /**< "T_SQL.test" */
   <%
//      static int x;
      T_SQL_Module *data;
      Eina_Bool ret = EINA_TRUE;

      data = T_SQL_module_data_get(module); /**< demonstrate use of generated define */
      if (data != data_)
        printf("Serious problem here!\n");
      data->m = mysql_init(NULL); /** allocate memory for MYSQL object */
      /** connect to database using super secure credentials */
      if (!mysql_real_connect(data->m, "localhost", "zentific", "zentific", "zentific", 0, NULL, CLIENT_REMEMBER_OPTIONS))
        {
           ret = EINA_FALSE;
           goto out;
        }
      /** set an option for hahas */
      mysql_set_server_option(data->m, MYSQL_OPTION_MULTI_STATEMENTS_ON);

      /** make our query */
      if (mysql_real_query(data->m, "SELECT 1 = 1", sizeof("SELECT 1 = 1")))
        ret = EINA_FALSE;
out:
      mysql_close(data->m); /**< close db connection */
//      printf("Call #%i: %s!\n", ++x, ret ? "Success" : "Failure");
      return ret;
   %>
}
