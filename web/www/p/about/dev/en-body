<table class='main'>
<tr>
<td class='main'><div class="main">

<center><h1>Enlightenment DR17</h1></center>

<p>Enlightenment's Core Systems</p>

<p> Enlightenment has grown to be much more than a window manager. It has many systems that have grown on their own to support development of the next version (0.17) and all the effort is going into solidifying these systems to be more than solid to build on. This has lead to a lot of code being produced that is useful far and beyond a window manager. The idea is to share as much code as possible with other programs, and so a small army of shared libraries has evolved for Enlightenment. This page attempts to cover some of these (especially the more interesting ones) to give a good insight into why they exist, what they do, how to use them, and where they are going. </p>    <p> We refer to these systems as the EFL or Enlightenment Foundation Libraries, as they are the foundation of the project and the currently contain all the hard work. The intent is to have libraries that are extremely easy to use and learn, that optimize automatically for the programmer where possible and save the programmer time and effort in the long run. We believe we have achieved many of these goals and have some very unique aspects that may be of great interest to developers outside of the project to create some interesting or even amazing tools. </p> <h1>Enlightenment</h1> <img width="400" vspace="16" hspace="16" height="300" align="left" src="http://enlightenment.sourceforge.net/Enlightenment/DR17/images/_images/DR17_shot.png" class="shot" alt="Evas performance test program" />  <p> Enlightenment is the window manager and desktop shell. This is what most people think Enlightenment only is. It is the flagship piece of software, for sure, but it is not the only thing by a long shot. It is actually much more recent than any other part of EFL. </p>    <p>Enlightenment, as of DR0.17 (which hasn't been released yet. latest developent snapshots are 0.16.999) is our next-generation window manager. It does not use any advanced X extensions available on some new XServers yet, as it is striving to be backwards-compatible to all XServers even on the oldest machines. It is designed to not just use new features, but to also work on small, limited processing power devices as well as the most powerful of today's desktop and server processors. It is not the leanest of all window managers or the fastest, but it is near the top for speed, and near the bottom for size (compared to its counterparts that have equivalent functionality), but above all things it strives to be beautiful. We believe your desktop should not be an eyesore. It should be functional AND beautiful. Enlightenment allows you to entirely customise the look of it via themes to an extent most other window managers can only dream of - especially doing it at the same speed and efficiency. It is not ready for release to users yet, so we keep development mostly unsupported, but we do not stop users from installing and using it to get a taste of what is to come. </p>   <h1>Evas</h1> <img width="240" vspace="16" hspace="16" height="320" align="right" src="http://enlightenment.sourceforge.net/Enlightenment/DR17/images/_images/evas_shot1.png" class="shot" alt="Evas performance test program" />  <p> Evas is a display canvas. This is different to the usual &quot;immediate mode&quot; display system that most programmers are used to and exists at the Xlib, GDI and even OpenGL levels when doing graphics programming. The difference is that the programmer has to call routines to DRAW the screen or updated display by drawing one operation at a time, such as draw line, paste image, draw box, paste text. When the screen needs an update these operations are done again by the code, normally from the bottom-most element in the draw to the top (painters algorithm). This is &quot;immediate mode&quot; drawing. Evas is different. It is structural by nature, so instead of drawing, you describe the canvas contents (or scene) in terms of primitives (images, lines, boxes, polygons, text strings etc.) and properties (color, stacking, size, etc.). The drawing itself is handled by the canvas, which acts as a state machine, not actually doing any &quot;hard work&quot; until the canvas's render call is executed, at which time it evaluates the previous and the current state and appropriately updates the screen without the programmer having to know how this is done. </p>  <img width="240" vspace="16" hspace="16" height="320" align="left" src="http://enlightenment.sourceforge.net/Enlightenment/DR17/images/_images/evas_shot2.png" class="shot" alt="Ecore Evas test program" />  <p> Evas is a very core part of the EFL. It is the rendering and display management engine that sits under anything you see on a screen. It does all the work of managing display objects, their state, state changes, layering, rendering and scaling, image loading, text rendering, update handling, optimizing the display pipeline to avoid work and more. It does a lot of the grunt work of display, and is portable beyond <a href="http://www.x.org/">X</a>. It even runs in the framebuffer directly without needing <a href="http://www.x.org/">X</a>, under <a href="http://www.trolltech.com/products/qtopia/index.html">Trolltech's Qtopia</a>, on <a href="http://www.directfb.org/">DirectFB</a>, can render into a memory buffer, and use <a href="http://www.opengl.org/">OpenGL</a> to accelerate rendering. It is extremely flexible and very powerful, saving a lot of time writing repetitive drawing routines that often end up not performing optimally as to do so takes a lot of time, care and effort that most programmers would not want to spend, because it distracts from the important work of making their application. </p>    <p> <img width="225" vspace="16" hspace="16" height="246" align="right" src="http://enlightenment.sourceforge.net/Enlightenment/DR17/images/_images/evas_keitai.png" alt="Evas on embedded" /> </p>    <p> But despite all of the things that Evas can do, it is not very large. It has been kept small and lean to make it viable for use on NOT just heavy-weight desktops, but also on limited resource devices such as PDA's, mobile phones and Smart phones, Stereo systems, DVD Players, PVR/DVR Systems and more. It has already been ported to Mobile phones and PDA's, PVR/DVR systems and has proved itself capable of driving these displays very nicely with beautiful effects. The developer does not have to change how they code for a device or their desktop as the API and rendering are the same, so no special development environments or emulators are needed. This saves time and effort, allowing desktop and device code to be shared and maintained easily. Also since Evas hides the details of the devices display format, and virtualizes the display at an object level, the programmer doesn't need to care how to render things. They can use a standard system that is universal across all instances of Evas. </p>    <p> Evas provides alpha blending, high quality scaling of images, anti-aliased truetype text, gradients, lines, polygons and more. The list of supported objects is growing, and can be extended via smart objects. It has an interface mechanism to allow for video data to be efficiently handled (which is what Emotion exploits) and more. </p> <h1>Ecore</h1>  <p> Ecore is a modular group of very closely linked libraries that provide core event loop functionality and related tasks. As the core event loop it provides conversion of system signals into events, to avoid having to have re-entrant code, handle basic file descriptor watching and passing off control to appropriate callback routines where needed, handling timers, idle calls, and other general program infrastructure and loop code. </p>    <p> It also provides easy to use wrappers around common systems such as X, Evas (for setup and combining with X), the frame-buffer, configuration management, inter process communication, socket handling, client/server programming, text encoding conversions (e.g. EUCJP to UTF8), deferred job handling and more. This library is a big time saver and core infrastructure library that can be used to do all the basic things applications need to do, with minimal code and effort. </p>    <p> The best way to describe Ecore is as the cement between the bricks. It holds things together very nicely. In the later examples a lot of the setup and infrastructure are thanks to Ecore. </p> <h1>Edje</h1> <p><img width="256" vspace="16" hspace="16" height="192" border="0" align="right" src="http://enlightenment.sourceforge.net/Enlightenment/DR17/images/_images/edje_shot1_thm.png" class="shot" alt="Edje Test program" /></p>    <p> Edje is one of the more unique parts of EFL, combining many things that <a href="http://www.macromedia.com/">Shockwave / FLASH</a> can do with some things it can't, but instead of being designed as a player, it is designed as a slave library to be used by an application to enhance the applications content and display via external compressed data files. It is being expanded continuously, and thanks to its clean design is easy to improve. This is the theme engine behind Enlightenment 0.17 and beyond and at last formalizes Enlightenment themes in a simple and consistent manner. </p>    <p> A Quick list of its features: </p>    <ul>  <li>Scalable bitmap images</li>    <li>Highly compressed in-lined images</li>    <li>Lossless and lossy compression with or without alpha channel</li>    <li>In-lined compressed truetype fonts</li>    <li>Multiple inbuilt font effects</li>    <li>Automatic font sizing based on size or area</li>    <li>Text compression and ellipsis based cutting</li>    <li>Rectangle objects</li>    <li>Configurable color scheme system</li>    <li>Ability to embed Edje objects within Edje objects</li>    <li>Embryo scripting language for complex interactions</li>    <li>Sand-boxed scripts so they cannot do much damage</li>    <li>Alpha blending</li>    <li>Completely scalable and re-sizable layout and interface metrics</li>    <li>Completely calculated tweened animation for ultra-smooth display</li>  </ul>    <p> Currently Edje includes a C-like source file format (using braces and nesting similar to C syntax with XML-like nesting) known as &quot;EDC&quot; files that are compiled into binary archive &quot;EET&quot; files that are then used by the Edje library for display - just like a PNG or JPEG are not &quot;source&quot; themselves - they are a compressed, machine-friendly representation of an image. The same goes for EET files. </p>    <p> The plan in the long term is to provide a new version of the old Etcher tool that was produced for a predecessor prototype for Edje (called Ebits) which gave a user a powerful GUI tool to create such files and edit them. Since Edje is so much more powerful and complex than Ebits ever was, this work has not yet been done, but is on the drawing-board. </p> <h1>Embryo</h1> <p> Embryo is a virtual machine and compiler based on the <a href="http://www.compuphase.com/small.htm">Small</a> programming language. It has had many bugs fixed and a lot of portability work done to the engine and the compiler. It has been made smaller and simpler making it ideal for inclusion into any program wanting to use small pieces of &quot;script logic&quot; within a more complex system, but don't want to bring in the massive resources required by other languages such as Perl, Python, Java, Ruby, etc. </p>    <p> The Embryo engine is tiny. The core engine is less than 1700 lines of clean C code, with the entire virtual machine including basic string manipulation and math routines, headers and utility code being only 3000 lines of code. The memory requirements for a script are about 8-16Kb of RAM, and they execute very quickly as they are already compiled into bytecode. </p>    <p> Embryo scripts are completely sand-boxed, so they cannot access files, allocate memory, access the network, control processes or do anything that hasn't been explicitly granted to them as a natively exported function call. Therefore an Embryo script by nature is very safe in addition to being small and very fast. The only damage it can do is via any function calls a program may provide to let the script interface with the system, and this is the same danger inherent in ALL systems. The advantage is that the programmer doesn't need to worry about problems outside of this. </p>    <p> As an example of what an embryo script would look like, here is a simple recursive program with some basic programming constructs and operations: </p>    <p> </p>  <div class="fragment">  <pre>/* this is exported by the embryo test program so you can output results */<br /> native printf(format[], ...);<br /> <br /> /* in a stand-alone embryo script this is the function that is always called */<br /> /* first, otherwise it may work like a library where a caller program may */<br /> /* call specific functions */<br /> main()<br /> {<br />   new Float:value = randf();<br />   <br />   if (value &gt; 0.5)<br />     {<br />        new i;<br />        <br />        for (i = 0; i &lt; 20; i++)<br />          {<br /> 	    printf(&quot;value = %f, i = %in&quot;, value, i);<br /> 	 }<br />     }<br />   else<br />     {<br />        new val;<br />        <br />        val = recurse(3);<br />        printf(&quot;val = %in&quot;, val);<br />     }<br /> }<br /> <br /> recurse(val)<br /> {<br />    printf(&quot;recurse... val = %in&quot;, val);<br />    if (val &gt;= 10) return val;<br />    return recurse(val + 1);<br /> }</pre> </div>

</div></td>
</tr>
</table>
