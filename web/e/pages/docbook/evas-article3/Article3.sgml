<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.1//EN">

<article>

<articleinfo>
        <title>Evas Presentation, Part 3: Object Properties</title>

        <author>
                <firstname>David</firstname>
                <surname>Odin</surname>
                <affiliation>
                        <address><email>David@dindinx.org</email></address>
                </affiliation>
        </author>

        <othercredit>
                <firstname>Romain</firstname>
                <surname>Lerallut</surname>
                <contrib>Translation to English</contrib>
                 <affiliation>
                        <address><email>rlerallut@free.fr</email></address>            
                </affiliation>
        </othercredit>                                                                

        <abstract>                                                        
        <para>
Last month, we saw how to add objects to an existing canvas and how to modify
some of their properties. Today, we'll see how to access the properties of
existing objects on the canvas.
        </para>                                                         
        </abstract>
</articleinfo>                                                          



<section>
<title>Linked lists "à la Evas"</title>

<para>
For some of its operations, Evas uses linked lists. Since they are
used as return values for some functions, we must know how to manipulate them.
Evas lists are doubly linked, and each element is of _Evas_List type. The type
of a pointer to an element (or a pointer to a list) is Evas_List. The
accessible fields of an element are 'data', a generic pointer (void*) to the
data the element holds, and 'prev' and 'next' which are pointers to the
previous and following elements in the list.
</para>

<para>
An empty list is simply represented by the NULL pointer. There are four 
functions that can add an element to a list. The first add an element at the 
end of the list:
</para>

<programlisting>
Evas_List evas_list_append(Evas_List list, void *data);
</programlisting>

<para>
The 'list' parameter must be a list or the NULL pointer. The new element is
created, and its 'data' pointer will have the value provided by the 'data'
parameter. The function evas_list_append() returns a pointer to the start of
the list.
</para>

<para>
The following function works exactly in the same way, but it adds the element
at the start of the chain:
</para>

<programlisting>
Evas_List evas_list_prepend(Evas_List list, void *data);
</programlisting>

<para>
The returned value is again a pointer to the start of the list, which happens
to be the new element (since it was inserted at the beginning).
</para>

<para>
The last two functions that add an element to a list are:
</para>

<programlisting>
Evas_List evas_list_append_relative(Evas_List list, void *data, void *search);
Evas_List evas_list_prepend_relative(Evas_List list, void *data, void *search);
</programlisting>

<para>
They look for the element whose data is 'search'. If this element exists, a
new element is created with the 'data' data, and added after (respectively
before) it. If the element looked for does not exist the element is created
and added at the end (resp. the beginning) of the list.
</para>

<para>
To remove an element from a list, use this function:
</para>

<programlisting>
Evas_List evas_list_remove_list(Evas_List list, Evas_List element);
</programlisting>

<para>
This removes the element 'element' from the list 'list', and returns a
pointer to the beginning of the list. The memory used by the removed element
is freed, but not necessarily the one used by its data.
</para>

<para>
It is also possible to remove an element even when only its data is known:
</para>

<programlisting>
Evas_List evas_list_remove(Evas_List list, void *data);
</programlisting>

<para>
If more than one element have the same 'data' pointer, only the first is
removed. The return value is a pointer to the beginning of the list (which
can have changed if the removed element was the first one). If no element
contains the requested 'data' , this function has no effect.
</para>

<para>
To remove all the elements of a list, use:
</para>

<programlisting>
Evas_List evas_list_free(Evas_List list);
</programlisting>

<para>
This function returns always NULL. The  memory taken by the elements is freed.
</para>

<para>
Finally, it is possible to know if an element holding some specific  data 
exists in the list:
</para>

<programlisting>
void *evas_list_find(Evas_List list, void *data);
</programlisting>

<para>
This function returns 'data' is a match was found, or else returns NULL.
</para>

</section>

<section>
<title>Data attached to objects</title>

<para>
Objects displayed by the canvas can have some data associated for identification
, or to add some feature. For example, all objects can have a name. This name
is set by:
</para>

<programlisting>
void evas_object_set_name(Evas canvas, Evas_Object object, char *name);
</programlisting>

<para>
By default, Evas objects have no name. The 'name' parameter is internally copied,
so that if an object's name is changed the older name is freed. To remove an
object's name, simply call this function with 'name' being NULL.
</para>

<para>
Inversely, it is possible to read an object's name:
</para>

<programlisting>
char *evas_object_get_name(Evas canvas, Evas_Object object);
</programlisting>

<para>
If the object is nameless, the function returns NULL.
</para>

<para>
But the really interesting feature is that an object on a canvas can be found 
by its name:
</para>
<programlisting>
Evas_Object evas_object_get_named(Evas canvas, char *name);
</programlisting>
<para>
When this function is called, Evas will look on canvas 'canvas' the first
object whose name is 'name'. It is thus better to use different names for
each object. If no object is found, the function returns NULL.
</para>

<para>
It is also possible to add much more generic data to Evas objects. This
feature is key-based: to each data is associated an alphanumeric key which
identifies the data for future retrieval. To associate a key/data couple to 
an Evas object, use this function:
</para>
<programlisting>
void evas_put_data(Evas canvas, Evas_Object object,
                   char *key, void *data);
</programlisting>


<para>
The object's data, associated to a given key, can afterwards be retrieved  by
this function:
</para>

<programlisting>
void *evas_get_data(Evas canvas, Evas_Object object, char *key);
</programlisting>

<para>
If no data is found that corresponds to the 'key' key for the 'object' object,
the return value is  NULL.
</para>

<para>
A key and its data can be unlinked for a given object by this function:
</para>

<programlisting>
void *evas_remove_data(Evas canvas, Evas_Object object, char *key);
</programlisting>

<para>
All this can be seen has a hash table attached to each object.
</para>
</section>

<section>
<title>Properties common to all objects</title>

<para>
Some properties are common to all Evas objects, like position, size and color.
It is thus possible to know which object is at a given position:
</para>

<programlisting>
Evas_Object evas_object_at_position(Evas canvas, double x, double y);
</programlisting>

<para>
This function returns the first object found at position (x,y). If no
object is found at this position on the canvas, NULL is returned. If
multiple objects are found, only the upper one is returned. This function is
useful, for example, to know which object the user has clicked on.
We'll see this in more detail next month.
</para>


<para>
However, it is sometimes necessay to find <emphasis>all</emphasis> the objects stacked over a
given position. This is what returns this function:
</para>

<programlisting>
Evas_List evas_objects_at_position(Evas canvas, double x, double y);
</programlisting>

<para>
The parameters are the same as for the evas_objects_at_position() function, but
the return value is a linked lists in which the elements' data are the objects
present at (x,y). Again, if no object is found, NULL is returned.
</para>

<para>
It is also sometimes useful to know what are the objects that intersect a given
rectangle. It allows for example the user to select multiple objects at once.
This is what return this function:
</para>

<programlisting>
Evas_Object evas_object_in_rect(Evas canvas,
                                double x, double y,
                                double width,
                                double height);
</programlisting>

<para>
The 'x', 'y', 'width' and 'height' parameters define the rectangle in which the
search is made. This function returns the first object that at least
intersects the rectangle (even if it's not completely inside), or NULL if no
such objects exists on the canvas.
</para>

<para>
As well as before, the following function returns in a linked list /all/
the objects that intersect the rectangle:
</para>

<programlisting>
Evas_List evas_objects_in_rect(Evas canvas,
                               double x, double y,
                               double width,
                               double height);
</programlisting>

<para>
Another property common to all objects is their color. To know the color of an
object, for any type of Evas object, use this function:
</para>

<programlisting>
void evas_get_color(Evas canvas, Evas_Object object,
                    int *red, int *green, int *blue,
                    int *opacity);
</programlisting>

</section>

<section>
<title>Properties specific to text objects</title>

<para>
Text objects have quite a great number of properties that define them.
This is why there are many functions to query each of these properties.
To get the 'text' field of a text object, use this function:
</para>

<programlisting>
char *evas_get_text_string(Evas canvas, Evas_Object object);
</programlisting>

<para>
The function returns NULL if the object is not a text object, or if the
'text' field is empty.
</para>

<para>
In the same way, this function returns the name of the font used by a text
object:
</para>

<programlisting>
char *evas_get_text_font(Evas canvas, Evas_Object object);
</programlisting>

<para>
This function returns the size of the font:
</para>

<programlisting>
int evas_get_text_size(Evas canvas, Evas_Object object);
</programlisting>

<para>
Do not mistake it with the following functions that returns respectively the
width and height in pixels of the text object!
</para>

<programlisting>
double evas_get_text_width(Evas canvas, Evas_Object object);
double evas_get_text_height(Evas canvas, Evas_Object object);
</programlisting>

<para>
It is also possible to get information on a particular character. The following
function returns a bounding rectangle that contains exactly one character:
</para>

<programlisting>
void evas_text_at(Evas canvas, Evas_Object object,
                  int index,
                  double *rect_x, double *rect_y,
                  double *rect_width, double *rect_height);
</programlisting>

<para>
The 'index' parameter indicates the position of the character in the 'object'
object's text string. The rectangle's geometry is returned in the last four
parameters. The upper left corner is at (*rect_x,*rect_y), and the width
and height are returned in the doubles rect_width and rect_height point to.
</para>

<para>
This function makes it easy for example to highlight a letter or a word:
just create a semi-transparent rectangle on top of the letter. We now see how
we could implement a function allowing the user to select some text with the mouse. 
Actually, this can be made even simpler by this function:
</para>

<programlisting>
int evas_text_at_position(Evas canvas, Evas_Object object,
                          double x, double y,
                          double *rect_x, double *rect_y,
                          double *rect_width, double *rect_height);
</programlisting>

<para>
This function checks which character is displayed at (x,y) from the upper left
corner of the 'object' object. The return value is the index of the character
in the string, of -1 if there is no character at this position. Besides, the
bounding rectangle is returned in the last four arguments of the function,
in the same fashion as for evas_text_at();
</para>

<programlisting>
void evas_text_get_ascent_descent(Evas canevas, Evas_Object objet,
                                  double *ascent, double *descent);
</programlisting>

<para>
To align characters horizontally, knowing their height is not enough. 
The useful information is the height above the baseline named 'ascent', and
the height under the baseline, named 'descent'. 
These numbers make it possible to align the baselines of two text objects.
To get them, use this function:
</para>

<programlisting>
void evas_text_get_ascent_descent(Evas canvas, Evas_Object object,
                                  double *ascent, double *descent);
</programlisting>

<para>
This function returns the ascent and descent of the font used by the object,
as the font specifies it. However, there can be some special characters (as
illuminated capital letters) that are bigger. The following function returns the
same data as evas_text_get_ascent_descent(), but by checking
all the font's characters and returning the extremal values.
</para>

<programlisting>
void evas_text_get_max_ascent_descent(Evas canvas, Evas_Object object,
                                      double *ascent, double *descent);
</programlisting>

<para>
Ideally, both functions should return the same values. Fortunately this is
generally the case.
</para>

</section>

<section>
<title>Properties of polygon objects</title>

<para>
The only remarkable property of a polygon object is its vertex set. 
The following function returns the vertex list of a polygon object:
</para>

<programlisting>
Evas_List evas_get_points(Evas canvas, Evas_Object object);
</programlisting>

<para>
This function returns a linked list whose elements hold pointers to
Evas_Point structures:
</para>

<programlisting>
typedef struct _Evas_Point *Evas_Point;

struct _Evas_Point
{
  double x, y;
};
</programlisting>

<para>
Where x and y are two doubles representing the coordinates of one of the
polygon's vertices. If the object is not a polygon, or if its vertices have
not yet been defined, the function returns NULL.
</para>

</section>

<section>
<title>Image object properties</title>

<para>
Images have several interesting properties: for example, the following function
returns whether an image is completely opaque or not:
</para>

<programlisting>
int evas_get_image_alpha(Evas canvas, Evas_Object object);
</programlisting>

<para>
This function returns 0 if the object is not an image, or if it is completely
opaque. It returns 1 if the object is an image with transparency.
</para>

<para>
The size of the image (in pixels) can be different from that of the object
that displays it, since the image can have been scaled to fit the object.
The following function returns the size of the image itself, as opposed to 
that of the parent Evas object which displays it:
</para>

<programlisting>
void evas_get_image_size(Evas canvas, Evas_Object object,
                         int *width, int *height);
</programlisting>

<para>
As we saw last month, it is possible to define a border around the image that
will not be stretched or shrunk when the image itself is scaled. The 
parameters of this border are returned by calling this function:
</para>

<programlisting>
void evas_get_image_border(Evas canvas, Evas_Object object, int *left, int *right, int *top, int *bottom);
</programlisting>

<para>
The last four parameters are pointers to integers that will be set to the
left, right, top and bottom borders width FIXME of the image.
</para>

<para>
Finally, when loading an image from  a file, all kinds of errors can occur.
The following function can help identify the type of error:
</para>

<programlisting>
Imlib_Load_Error evas_get_image_load_error(Evas canvas, Evas_Object object);
</programlisting>

<para>
The return value is one of the following, and can be used for some 
more advanced error management:
</para>

<programlisting>
IMLIB_LOAD_ERROR_NONE : the loading has succeeded
IMLIB_LOAD_ERROR_FILE_DOES_NOT_EXIST,
IMLIB_LOAD_ERROR_FILE_IS_DIRECTORY,
IMLIB_LOAD_ERROR_PERMISSION_DENIED_TO_READ,
IMLIB_LOAD_ERROR_NO_LOADER_FOR_FILE_FORMAT,
IMLIB_LOAD_ERROR_PATH_TOO_LONG,
IMLIB_LOAD_ERROR_PATH_COMPONENT_NON_EXISTANT,
IMLIB_LOAD_ERROR_PATH_COMPONENT_NOT_DIRECTORY,
IMLIB_LOAD_ERROR_PATH_POINTS_OUTSIDE_ADDRESS_SPACE,
IMLIB_LOAD_ERROR_TOO_MANY_SYMBOLIC_LINKS,
IMLIB_LOAD_ERROR_OUT_OF_MEMORY,
IMLIB_LOAD_ERROR_OUT_OF_FILE_DESCRIPTORS,
IMLIB_LOAD_ERROR_PERMISSION_DENIED_TO_WRITE,
IMLIB_LOAD_ERROR_OUT_OF_DISK_SPACE,
IMLIB_LOAD_ERROR_UNKNOWN
</programlisting>

<para>
The names are by themselves quite explicit.
</para>

<para>
Let's now see most of these functions in some example code.
</para>

<programlisting>
/* properties */
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;Evas.h&gt;

void highlight(Evas canvas, int index)
{
  double      x, y, width, height;
  double      x_text, y_text;
  Evas_Object rectangle, text;

  text = evas_object_get_named(canvas, "Texte");
  evas_get_geometry(canvas, text,
                    &amp;x_text, &amp;y_text, NULL, NULL);
  evas_text_at(canvas, text, index, &amp;x, &amp;y,
               &amp;width, &amp;height);
  rectangle = evas_add_rectangle(canvas);
  evas_show(canvas, rectangle);
  evas_set_color(canvas, rectangle, 255, 0, 0, 128);
  evas_move(canvas, rectangle, x_text+x, y_text+y);
  evas_resize(canvas, rectangle, width, height);  
}

int main(int argc, char *argv[])
{
  XSetWindowAttributes  att;
  Display              *display;
  Visual               *visual;
  Colormap              colormap;
  Window                window;
  Evas                  canvas;
  Evas_Object           rectangle, text;
  int                   i;
  Evas_List             list;

  /* Creating the canvas */
  canvas = evas_new();
  /* Choosing the rendering method */
  evas_set_output_method(canvas, RENDER_METHOD_ALPHA_SOFTWARE);
  /* Getting the X Window variables */
  display = XOpenDisplay(NULL);
  visual = evas_get_optimal_visual(canvas, display);
  colormap = evas_get_optimal_colormap(canvas, display);

  /* Opening a window */
  att.colormap = colormap;
  window = XCreateWindow(display,
                          RootWindow(display, DefaultScreen(display)),
                          0, 0, 300, 200, 0,
                          imlib_get_visual_depth(display, visual),
                          InputOutput, visual, CWColormap, &amp;att);
  XMapWindow(display, window);
  XSync(display, False);

  /* attaching the canvas to the window */
  evas_set_output(canvas, display, window, visual, colormap);

  /* setting the canvas' size to that of the window */
  evas_set_output_size(canvas, 300, 200);
  evas_set_output_viewport(canvas, 0, 0, 300, 200);

  /* Drawing a bunch of rectangles */
  for (i=0 ; i<100 ; i++)
  {
    int x1, y1, x2, y2;
    rectangle = evas_add_rectangle(canvas);
    evas_show(canvas, rectangle);
    evas_set_color(canvas, rectangle,
    rand()%256, rand()%256, rand()%256, rand()%256);
    x1 = rand()%300; y1 = rand()%100;
    x2 = rand()%300; y2 = rand()%100;
    evas_move(canvas, rectangle, x1, y1);
    evas_resize(canvas, rectangle, x2-x1, y2-y1);
    evas_put_data(canvas, rectangle, "x1", (void*)x1);
    evas_put_data(canvas, rectangle, "x2", (void*)x2);
    evas_put_data(canvas, rectangle, "y1", (void*)y1);
    evas_put_data(canvas, rectangle, "y2", (void*)y2);
  }

  /* some text */
  text = evas_add_text(canvas, "grunge", 20, "Vive Evas !");
  evas_object_set_name(canvas, text, "Texte");
  evas_show(canvas, text);
  evas_set_color(canvas, text, 255, 255, 255, 255);
  evas_move(canvas, text, 20, 100);

  /* highlighting the letters of 'Evas' */
  for (i=5 ; i<9 ; i++)
    highlight(canvas, i);
 
  /* asking Evas to display it all */
  evas_update_rect(canvas, 0, 0, 300, 200);
  evas_render(canvas);

  /* display the properties of some rectangles */
  list = evas_objects_in_rect(canvas, 20, 20, 260, 160);
  while (list)
  {
    int x1, x2, y1, y2, rouge, vert, bleu, opacite;
    rectangle = (Evas_Object)(list->data);
    
    /* coordinates */
    x1 = (int)evas_get_data(canvas, rectangle, "x1");
    x2 = (int)evas_get_data(canvas, rectangle, "x2");
    y1 = (int)evas_get_data(canvas, rectangle, "y1");
    y2 = (int)evas_get_data(canvas, rectangle, "y2");
    /* color */
    evas_get_color(canvas, rectangle,
                   &amp;rouge, &amp;vert, &amp;bleu, &amp;opacite);
    
    printf("(%d, %d) - (%d, %d) <%d, %d, %d,  %d>\n",
           x1, y1, x2, y2, rouge, vert, bleu, opacite);
    list = evas_list_remove_list(list, list);
  }
  
  /* infinite loop so that we have time to admire it all */
  for (;;);
  return 0;
}
</programlisting>

<para>
Compile the program like this:
</para>

<programlisting>
gcc evas.c -o evas -O2 -g -Wall `evas-config --cflags --libs`
</programlisting>

</section>

<section>
<title>Next time</title>

<para>
Next time, we will finish our presentation of Evas by taking a long look
on the event processing system.
</para>

</section>
</article>
