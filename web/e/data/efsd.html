@top@
@start@
<p class="contenttitle">Efsd</p>
<p style="text-align:justify">
<b>Efsd</b>, the Enlightenment File System Daemon, is a daemon that provides commonly needed file system
functionality to one or more clients. It comes as a library that
clients (like e17) use, sending commands to the daemon, which asynchronously reports back the outcome of the
commands when their execution is finished. <b>Efsd</b> therefore decouples the client 100% from any file system related
tasks (which means that you will for example not see a GUI application hang, assuming it is coded sanely),
specifically, it does the following:
</p>
<table width="85%" align="center">
  <tr>
    <td>
      <ul>
       <li><p style="text-align:justify">Implements basic file operations (ls, cp, rm, ln -s, stat ...), with a flexible option passing
	      system to provide equivalents of recursive processing, force options, alphabetical sorting etc.</p></li>
       <li><p style="text-align:justify">Reports file change events, currently using <a href="http://oss.sgi.com/projects/fam/">FAM</a>,
              so that a client gets instant reports when files are removed, deleted, renamed etc. I've looked
              at BSD's kqueue mechanism and Linux 2.4's dnotify, and it seems Rusty and his friends at SGI are
              planning on adding direct support for these to FAM (well, at least for the kqueue mechanism).</p></li>
       <li><p style="text-align:justify">Delivers file type requests to the clients, i.e. clients ask for a file's type, and <b>Efsd</b>
              does its best to come up with a good reply. <b>Efsd</b> extends the concept of MIME types for data
              type specification to more than two levels (e.g. "image/gif/89a"), to allow arbitrary levels of
              granularity. A three-tiered approach is used to determine the file type, not unlike the way the
              Unix file(1) command works. These three levels are tried in order of decreasing reliability:</p>
           <ul>	
             <li>First, the result of stat() and statfs() calls are checked to see if a file is a directory,
                 socket, fifo etc. In that case, a reply like "ext2/directory" is reported.</li>
             <li>If that didn't help, file magic is used to check for detailed file characteristics. A database
                 based on a magic file (check man magic for details) is used to put together a detailed file type.
                 <b>Efsd</b> can therefore deliver file types with the same high level of granularity that file(1)
                 provides, for example, asking for an mp3's file type results in a reply as detailed as
                 <b>audio/mp3/160-kbit-s/44-1-khz/jstereo</b>. It is up to the client to make as much use of the
                 information as necessary.</li>
             <li>If that also didn't help, classic file name pattern matching is used, e.g. anything *.foo is a
                 foobar file etc.</li>
           </ul>
	   <p style="text-align:justify">
             File type lookups are cached in order to increase performance.
           </p>
           <p style="text-align:justify">
             With a client that uses <b>Efsd</b>, no user will ever click on what seems to be an mp3, accidentally executing a malicious script.
           </p>           
       </li>
       <li><p style="text-align:justify">Handles setting and retrieval of arbitrary metadata, e.g.
	      like storing/querying for file icons, icon coordinates etc. The
              type of data to be stored/retrieved is entirely up to the clients.
           </p></li>
       <li><p style="text-align:justify">Can monitor metadata and sent events to the client when
	      metadata entries change.
           </p></li>
       <li><p style="text-align:justify">Caches results of stat() calls to increase performance. FAM is used to let <b>Efsd</b> know
              internally when a file has changed, so that cached stats can be updated.
           </p></li>
       <li><p style="text-align:justify">Supports multiple clients. Besides the simpler case of regular fs commands, <b>Efsd</b> implements
              filechange event (de-)multiplexing, i.e. file monitoring requests are use-counted and resulting events
              are forwarded to the appropriate clients which requested the monitoring. <b>efsdsh</b>, an interactive
              command line interface to <b>libefsd</b> is a nifty little tool for testing things like these ...
           </p></li>
       <li><p style="text-align:justify">Multi-threaded implementation, as long as POSIX threads (pthreads) are available on a system.</p></li>
      </ul>
    </td>
  </tr>
</table>
<p style="text-align:justify">
<b>Efsd</b> is currently around 16,000 lines of C code, and mostly stable. It's available in
Enlightenment's CVS repository, go to the <a href="http://www.sourceforge.net/projects/enlightenment">SourceForge page</a>
for details. The Efsd Manual is available for download as HTML <a href="http://www.whoop.org/downloads/efsd-manual.tgz">here</a>, an online
version is up <a href="http://www.whoop.org/efsd-manual/index.html">here</a>.
</p>
@end@
@bottom@
