#! @PERL@ -w

#
# Copyright (C) 2000, 2001 Christian Kreibich <kreibich@aciri.org>.
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to
# deal in the Software without restriction, including without limitation the
# rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
# sell copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies of the Software and its documentation and acknowledgment shall be
# given in the documentation and software packages that this Software was
# used.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
# IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

use strict;

# Globals
#___________________________________________________________________________
my $magic_file;
my $db_file;

# Efsd Constants
#___________________________________________________________________________
my $EFSD_MAGIC_8       = 0;
my $EFSD_MAGIC_16      = 1;
my $EFSD_MAGIC_32      = 2;
my $EFSD_MAGIC_STRING  = 3;

my $EFSD_MAGIC_TEST_EQUAL     = 0;
my $EFSD_MAGIC_TEST_NOTEQUAL  = 1;
my $EFSD_MAGIC_TEST_SMALLER   = 2;
my $EFSD_MAGIC_TEST_LARGER    = 3;
my $EFSD_MAGIC_TEST_MASK      = 4;
my $EFSD_MAGIC_TEST_NOTMASK   = 5;

my $EFSD_BYTEORDER_HOST       = 0;
my $EFSD_BYTEORDER_BIG        = 1;
my $EFSD_BYTEORDER_SMALL      = 2;


# Prototypes
#___________________________________________________________________________

sub e_db_int_set;
sub e_db_str_set;
sub to_dec;
sub write_magic;
sub do_it;

sub e_db_int_set {
  
  my $db  = $_[0];
  my $key = $_[1];
  my $val = $_[2];
  my @command = ("@EDB_ED@", $db, "add", $key, "int", $val);

  system(@command) == 0
    or die "edb_ed call failed: $?";
}

sub e_db_str_set {

  my $db  = $_[0];
  my $key = $_[1];
  my $val = $_[2];
  my @command = ("@EDB_ED@", $db, "add", $key, "str", $val);

  system(@command) == 0
    or die "edb_ed call failed: $?";
}


sub to_dec {
 
  my $value = $_[0];

  if (substr($value, 0, 1) eq "0")
    {
      if (substr($value, -1) eq "L")
	{
	  $value = oct(substr($value,0,-1));
	}
      else
	{
	  $value = oct($value);
	}
    }

  $value;
}

sub write_magic {

  my $indices_ptr = $_[0];
  my $level       = $_[1];
  my $magic_ptr   = $_[2];
  my $s;
  my $key;
  my $i;

  for ($i = 0, $s = "/"; $i <= $level; $i++)
    {
      $s = $s . $$indices_ptr[$i] . "/";
    }
  
  if (defined($$magic_ptr{"offset"}))
    {
      $key = $s . "offset";
      e_db_int_set($db_file, $key, $$magic_ptr{"offset"});
    }
  if (defined($$magic_ptr{"byteorder"}))
    {
      $key = $s . "byteorder";
      e_db_int_set($db_file, $key, $$magic_ptr{"byteorder"});
    }
  if (defined($$magic_ptr{"type"}))
    {
      $key = $s . "type";
      e_db_int_set($db_file, $key, $$magic_ptr{"type"});
    }
  if (defined($$magic_ptr{"mask"}))
    {
      $key = $s . "mask";
      e_db_int_set($db_file, $key, $$magic_ptr{"mask"});
    }
  if (defined($$magic_ptr{"value"}))
    {
      $key = $s . "value";
      e_db_int_set($db_file, $key, $$magic_ptr{"value"});
    }
  if (defined($$magic_ptr{"mime"}))
    {
      $key = $s . "mimetype";
      e_db_str_set($db_file, $key, $$magic_ptr{"mime"});
    }
}


sub do_it {

  my @indices;
  my @strings;
  my $line;
  my $level;
  my $old_level = -1;
  my $s;
  my $i;
  my $item;
  my %magic;
  my $dropped_level;

  open (MAGIC, $magic_file)
    or die "Can't open magic file $magic_file: ";

  $dropped_level = 1000000;

  while ($line = <MAGIC>)
    {     
      unless (($line =~ /#.*/m) || ($line =~ /^$/m))
	{

	 # Okay -- it's a magic definition -- parse it.
	 
	 if ($line =~ /^(>*)                                # level of the test
	                ((?:0x)??[0-9a-fA-F]+) \s+          # numerical offset
	                (be|le)??(byte|short|long|string)   # endianness and type, no date
                        (&(?:0x)??[0-9a-fA-F]+)?? \s+       # possibly, a mask for the value
	                ([!<>&\^=]?)((?:0x)??[0-9a-fA-F]+?| # test for either a num. value
                        (?:\\ |\S){2,}?|[^x]{1}) \s+        # or a string
	                (.*)$/x)                            # and finally, the comment.
	   {
	     $level = length($1);

	     if ($level > $dropped_level)
	       {
		 next;
	       }
	     else
	       {
		 $dropped_level = 1000000;
	       }

	     if ($level > $old_level)
	       {
		 $indices[$level] = 0;
	       }
	     else
	       {
		 $indices[$level]++;
	       }
	
	     $old_level = $level;

	     # Write offset:
	     $item = $2;
	     $magic{"offset"} = to_dec($item);

	     # Write byteorder:
	     if (defined ($3))
	       {
		 $item = $3;
		 if ($item eq "be")
		   {
		     $magic{"byteorder"} = $EFSD_BYTEORDER_BIG;
		   }
		 elsif ($item eq "le")
		   {
		     $magic{"byteorder"} = $EFSD_BYTEORDER_SMALL;
		   }
		 else
		   {
		     $magic{"byteorder"} = $EFSD_BYTEORDER_HOST;
		   }
	       }
	     else
	       {
		 $magic{"byteorder"} = $EFSD_BYTEORDER_HOST;
	       }

	     # Write type:
	     $item = $4;
	     if ($item eq "byte")
	       {
		 $magic{"type"} = $EFSD_MAGIC_8;
	       }
	     elsif ($item eq "short")
	       {
		 $magic{"type"} = $EFSD_MAGIC_16;
	       }
	     elsif ($item eq "long")
	       {
		 $magic{"type"} = $EFSD_MAGIC_32;
	       }
	     else
	       {
		 $magic{"type"} = $EFSD_MAGIC_STRING;
	       }

	     # Write mask:
	     if (defined ($5))
	       {
		 $item = substr($5,1);
		 $magic{"mask"} = to_dec($item);
	       }

	     # Write test-type:
	     if (defined ($6))
	       {
		 $item = $6;
		 if ($item eq "<")
		   {
		     $magic{"test"} = $EFSD_MAGIC_TEST_SMALLER;
		   }
		 elsif ($item eq ">")
		   {
		     $magic{"test"} = $EFSD_MAGIC_TEST_LARGER;
		   }
		 elsif ($item eq "&")
		   {
		     $magic{"test"} = $EFSD_MAGIC_TEST_MASK;
		   }
		 elsif ($item eq "^")
		   {
		     $magic{"test"} = $EFSD_MAGIC_TEST_NOTMASK;
		   }
		 elsif ($item eq "!")
		   {
		     $magic{"test"} = $EFSD_MAGIC_TEST_NOTEQUAL;
		   }
		 else
		   {
		     $magic{"test"} = $EFSD_MAGIC_TEST_EQUAL;
		   }
	       }
	     else
	       {
		 $magic{"test"} = "equal";
	       }

	     # Write value:
	     $item = $7;
	     if ($magic{"type"} eq "string")
	       {
		 $magic{"value"} = $item;
	       }
	     else
	       {
		 $magic{"value"} = to_dec($item);
	       }

	     # Write description:

	     # Let's make a bunch of passes on the comment to get
	     # rid of all kind of weird formatting stuff.

	     $item = $8;
	     $item =~ s/%.//g;  # get rid of print formatters
	     $item =~ s/\\.//g; # get rid of anything escaped
	     $item =~ s/\W/-/g; # replace anything non-alpha with dashes
	     $item =~ s/-+/-/g; # replace multiple dashes with single one.
	     $item =~ s/^(-+)//;# remove any dashes at beginning
	     $item =~ s/(-+)$//;# remove any dashes at end
	     $item = lc($item);

	     if (length($item) == 0)
	       {
		 $item = "empty";
	       } 
	     
	     $s = "";
	     
	     if ($level > 0)
	       {
		 $s = $strings[0] . "/";

		 for ($i = 1; $i < $level; $i++)
		   {
		     $s = $s . $strings[$i] . "-";
		   }
	       }

	     $s = $s . $item;

	     $strings[$level] = $item;
	     $magic{"mime"} = $s;

	     write_magic(\@indices, $level, \%magic);
	   }
	 else
	   {
	     print "Dropped line: $line";
	     $dropped_level = $level;
	   } 
	}
    }
}


# MAIN PROGRAM
#___________________________________________________________________________


if (@ARGV < 2)
  {
    print "USAGE: $0 <magic file> <db file>.\n";
    exit;
  }

$magic_file = shift(@ARGV);
$db_file = shift(@ARGV);

do_it();
