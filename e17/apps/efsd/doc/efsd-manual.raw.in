<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V3.1//EN" [
<!ENTITY efsd "<function>efsd</function>">
<!ENTITY lefsd "<function>libefsd</function>">
<!ENTITY efsdsh "<function>efsdsh</function>">
]>


<book id="efsd-manual">
  <bookinfo>
    <title>The EFSD Programming Manual</title>
    
    <authorgroup>
      <author>
	<firstname>Christian</firstname>
	<othername></othername>
	<surname>Kreibich</surname>
	<affiliation>
	  <address>
	    <email>cK@whoop.org</email>
	  </address>
	</affiliation>
      </author>
    </authorgroup>
    
    <copyright>
      <year>2001</year>
      <holder>Christian Kreibich</holder>
    </copyright>
    
    <legalnotice>
      <para>
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to
	deal in the Software without restriction, including without limitation the
	rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	sell copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
      </para>
      <para>
	The above copyright notice and this permission notice shall be included in
	all copies of the Software and its documentation and acknowledgment shall be
	given in the documentation and software packages that this Software was
	used.
      </para>
      <para>
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
	THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
	IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
      </para>
    </legalnotice>

    <releaseinfo>
      This is document is nowhere near being finished. Be patient.
    </releaseinfo>
    
  </bookinfo>

  <toc></toc>

  <chapter id="introduction">
    <title>Introduction</title>
    <para>
      This is the manual for &efsd;, the Enlightenment File System Daemon.
      The purpose of &efsd; is to provide a facility that allows applications
      to issue commands on filesystems (such as the familiar <command>cp</command>,
      <command>mv</command> and <command>rm</command>, but much more than that)
      in a non-blocking fashion
      and get reports on the outcome of those commands asynchronously.      
    </para>
    <para>
      If you're not sure why this is a good thing, read
      <link linkend="why" endterm="why.title"></link>. If you want to jump right
      in, Chapter <link linkend="libefsd" endterm="libefsd.title"></link> has
      the gory details of using &lefsd;. If you want to go even further and read
      the code, Chapter <link linkend="efsd" endterm="efsd.title"></link> is the
      thing for you.
    </para>
    <para>
      I'd like to thank Raster <email>raster@rasterman.com</email> for talking
      me into writing &efsd; during one of our dinner sessions somewhere in San
      Francisco in late 2000. I've had and am still having a blast working on it.
      I'd also like to thank the various people who have contributed suggestions,
      feedback and patches. Their names can always be found in the
      <filename>AUTHORS</filename> file.
    </para>
  </chapter>

  <chapter id="overview">
    <title id="overview.title">Overview of &efsd;</title>
    <section id="why">
      <title id="why.title">Why use it?</title>
      <para>
      </para>
    </section>
    <section>
      <title>Using &efsd; in Your Application</title>
      <para>
	What is usually referred to as &efsd; actually comes in two parts -
        the &efsd; server daemon and a library to be used by the clients, called
        &lefsd;. When referring to the software package &efsd;, the combination
        of both the server and the library is meant. Context should make clear
	what is referred to.
      </para>
      <para>
        To enable your application to use &efsd;, all you have to
        do is link your application against &lefsd;. In the tradition of
	the various configuration scripts that lots of software packages
	are providing now (think of <command>gtk-config</command>,
	<command>gnome-config</command> etc), &efsd; has
        <command>efsd-config</command>, which reports the necessary compilation
        and linkage flags.
      </para>
      <para>
        When running your application, the &efsd; daemon must be up and running.
        You can do this by simply issuing the <command>efsd</command> command (see
        <command>efsd --help</command> for the available options), or your
        application can launch it for you (although it should do so only after
        making sure that an &efsd; instance isn't already running).
      </para>
      <para>
        &efsd; has only few requirements. Right now they are

	<itemizedlist mark="opencircle">
	  <listitem>
	    <para>
              FAM, the File Alteration Monitor, available at
              <ulink url="http://oss.sgi.com/projects/fam">SGI's Open Source site</ulink>.
            </para>
          </listitem>
	  <listitem>
	    <para>
              Edb, the Enlightenment Database, based on BerkeleyDB. It's available on
              Enlightenment's SourceForge 
              <ulink url="http://prdownloads.sourceforge.net/enlightenment">download page</ulink>.
            </para>
          </listitem>
	</itemizedlist>
      </para>
    </section>
    <section>
      <title>&efsd; Architecture Overview</title>
      <para>
	The purpose of this section is to give an overview of the general architecture of &efsd;,
	to give the user a rough idea of how it works, what are smart things to do when programming
         &lefsd; and what are not.
      </para>
	  
      <mediaobject>
        <imageobject>
          <imagedata fileref="figures/architecture.eps" format="eps">
        </imageobject>
        <imageobject>
          <imagedata fileref="figures/architecture.gif" format="gif">
        </imageobject>
        <textobject>
          <phrase>Image of &efsd; Architecture</phrase>
        </textobject>
        <caption>
          <para>&efsd; Architecture.</para>
        </caption>
      </mediaobject>

      <para>
        As can be seen in the Figure, multiple clients talk to &efsd; through &lefsd;. &efsd; in turn
	is composed of a number of subsystems which handle command-specific tasks, accessing the
	filesystem through system calls into the kernel. <link linkend="monitoring">Monitoring of files</link>
	is done through <function>libfam</function> and <function>FAM</function>, the File Alteration
        Monitor (available at <ulink url="http://oss.sgi.com/projects/fam"><citetitle>SGI's oss site</citetitle></ulink>).
      </para>
    </section>
  </chapter>

  <chapter id="libefsd">
    <title id="libefsd.title">&lefsd; - The Client Side of &efsd;</title>
    <section>
      <title>Using &lefsd;</title>
      <para>
	The way applications talk to &efsd; is through
	&lefsd;. &lefsd; handles
	all the dirty low-level work (such as the I/O details of sending commands
	and receiving replies) and provides a convenient API to the clients.
	The following sections will briefly introduce general concepts
	before the API is explained in detail.
      </para>
      <section>
	<title>Opening a Connection to &efsd;</title>
	<para>
	  Before you can launch any commands, you need to establish a
	  connection to &efsd; via <link linkend="API-efsd-open">
	    <function>efsd_open()</function></link>. The returned
	  &efsd; pointer is used to identify the connection and is passed as
	  first parameter to basically every function. When you're done, you can tear down the connection
	  and release the allocated memory using <link linkend="API-efsd-close">
	    <function>efsd_close()</function></link>.
	  <programlisting>

EfsdConnection *ec;

if ( (ec = efsd_open()) == NULL)
  {
     /* Oops. Couldn't establish connection.
      * Is Efsd really running ? 
      */
  }

/* ... various efsd commands ... */

if (efsd_close(ec) < 0)
  {
     /* Ouch. Error when closing connection. */
  }
	  </programlisting>
	</para>
      </section>
      <section>
	<title>Sending Commands</title>
	<para>
	  After opening a connection, the client is ready to launch commands.
	  You can send commands for the following tasks:

	  <itemizedlist mark="opencircle">
	    <listitem>
	      <para>Copying, moving, removing files and directories(<function>cp</function>,
		<function>mv</function>, <function>rm</function>)</para>
	    </listitem>
	    <listitem>
	      <para>Creating directories (<function>mkdir</function>)</para>
	    </listitem>
	    <listitem>
	      <para>Creating symbolic links (<function>ln -s</function>)</para>
	    </listitem>
	    <listitem>
	      <para>Getting the target of a link (<function>readlink</function>)</para>
	    </listitem>
	    <listitem>
	      <para>Setting permissions (<function>chmod</function>)</para>
	    </listitem>
	    <listitem>
	      <para>Listing directory contents (<function>ls</function>)</para>
	    </listitem>
	    <listitem>
	      <para>Setting and getting metadata</para>
	    </listitem>
	    <listitem>
	      <para>Getting filetype information</para>
	    </listitem>
	    <listitem>
	      <para><function>stat</function> and <function>lstat</function></para>
	    </listitem>
	    <listitem>
	      <para>File monitoring</para>
	    </listitem>
	  </itemizedlist>
	  
	  When a command is sent to the server, you get a command ID in
	  return, which is guaranteed to be unique, and can therefore be
	  used to associate replies from &efsd; and
	  sent commands. The exception is the unlikely case that the
	  write buffer from the client to the server does not have enough
	  room for the command, in this case a value &lt; 0 is returned.
	  This is rather unlikely, however, robust code should always
	  check the result like this:

	  <programlisting>

EfsdConnection *ec;
EfsdCmdId id;

if ( (ec = efsd_open()) == NULL)
  {
     /* Oops. Couldn't establish connection.
      * Is Efsd really running ?
      */
  }

if ( (id = efsd_makedir(ec, "foo/bar")) < 0)
  {
     /* Could not send command. Continue accordingly. */
  }
	  </programlisting>

	  <note>
	    <title>A return value &lt; 0 does not mean that an error occured when processing the command.</title>
	    <para>
	      It means that the command didn't get sent to the server in the
	      first place. Errors during actual execution of the commands are
	      reported as error codes in the returned replies.
	    </para>
	  </note>

	  If you don't check the return value, the receiving part of your client
	  may be waiting for reply to a command that never got sent to &efsd;.
	  &efsd; does not queue those requests on the client side, as the urgency of
	  the commands depends on the application setting. For some scenarios,
	  queueing may be appropriate, while for others, simply discarding
	  the command may be better. The decision is left to the client.
	</para>
      </section>

      <section>
	<title>Receiving Events</title>
        <para>
	There are two basic ways of receiving events from &efsd; in your client:
	Using <function>select()</function> to wait on events on file descriptors,
	or using &lefsd;'s convenience functions which block and wait until events
	arrive.
        </para>
	<section>
	  <title>Using <function>select()</function> and File Descriptors</title>
          <para>
	  This is the more sophisticated and flexible way, well-suited for complex
	  event loops. Use <link linkend="API-efsd-get-connection-fd"><function>
	  efsd_get_connection_fd()</function></link> to get the connection's file
	  descriptor. You can then <function>ioctl()</function> this descriptor to
	  enable e.g. nonblocking mode, then use <function>select()</function> as
	  usual. If you're not familiar with <function>select()</function>, have a
	  look at <link linkend="bib-apue"><citation>Stevens 1998</citation></link> or
	  <link linkend="bib-unp"><citation>Stevens 1992</citation></link>.
          </para>
	  <para>
	    The code in this case then usually looks like this:

	  <programlisting>  
EfsdConnection *ec;
fd_set          fdset;
int             fd, fdsize = 0;

if ( (ec = efsd_open()) == NULL)
  {
     /* Oops. Couldn't establish connection.
      * Is Efsd really running ?
      */
  }

fd = efsd_get_connection_fd(ec);

FD_ZERO(&amp;fdset);

/* Set desired filedescriptors here, also maybe
 * create other fd_sets ...
 */

/* ... */

FD_SET(fd, &amp;fdset);
if (fd > fdsize)
  fdsize = fd;

select(fdsize + 1, &amp;fdset, NULL, NULL, NULL);

/* Check for events on Efsd's descriptor */

if (FD_ISSET(fd, &amp;fdset))
  {	  
    EfsdEvent ee;

    /* Efsd events have arrived -- now loop while
     * there are events pending in the arrival queue.
     */
   
    while (efsd_events_pending(ec))
      {
	 if (efsd_next_event(ec, &amp;ee) >= 0)
           {
              /* Handle the event */
	      /* ... */

              /* Now clean up: */
              efsd_event_cleanup(&amp;ee);
           }
	 else
           {
              /* Error while reading event. */
           }
      }
  }
	    </programlisting>
	    After adding the file descriptors to an <classname>fd_set</classname>,
            you <function>select()</function> the <classname>fd_set</classname>
            and check &efsd;'s file descriptor when <function>select()</function> returns.
	    One or more &efsd; events may have arrived. To read them, loop while
	    <link linkend="API-efsd-events-pending"><function>efsd_events_pending()
	    </function></link> returns a value greater than zero. You read the event
            into an <classname>EfsdEvent</classname> structure.

	  <caution>
	    <title>After you finished handling the event, you need to clean up the structure.</title>
            <para>
              Use <link linkend="API-efsd-event-cleanup"><function>efsd_event_cleanup()</function></link>
              to release any memore that was read into the <classname>EfsdEvent</classname> structure.
            </para>
	  </caution>
	  </para>
        </section>
	<section>
	  <title>Using &lefsd; and Blocking Waits</title>
          <para>
	    When you're not using complex event loops, a simpler way is to use
	    &lefsd;'s convenience functions for reading &efsd; events. The code
	    looks like this:

	  <programlisting>  
EfsdConnection *ec;
EfsdEvent ee;

if ( (ec = efsd_open()) == NULL)
  {
     /* Oops. Couldn't establish connection.
      * Is Efsd really running ?
      */
  }

while (efsd_wait_event(ec, &amp;ee) >= 0)
  {
     /* Handle the event */
     /* ... */

     /* Now clean up: */
     efsd_event_cleanup(&amp;ee);
  }
	  </programlisting>

	    After establishing the connection to &efsd; your event handler simply
            sits in a loop that calls <link linkend="API-efsd-wait-event">
	    <function>efsd_wait_event()</function></link> and blocks until an event
	    arrives . As before, after handling the event,
	    you need to clean up using <link linkend="API-efsd-event-cleanup"><function>
            efsd_event_cleanup()</function></link>.
          </para>
        </section>

	<section id="eventtypes">
	  <title id="eventtypes.title">Handling Event Types</title>
          <para>
	There are two kinds of reply events that you can receive:

	  <itemizedlist mark="opencircle">
	    <listitem>
	      <para>
                <emphasis>Reply Events</emphasis>, which report the result of a
	        command that was sent to &efsd;. There exist subtypes for the various
                kinds of replies that different commands require.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
                <emphasis>Filechange Events</emphasis>, which report that an
	        aspect of a monitored file has changed (more about file monitoring
                in Section <link linkend="monitoring" endterm="monitoring.title"></link>).
              </para>
	    </listitem>
	  </itemizedlist>

         An <classname>EfsdEvent</classname> is a union of the possible event
	 types, and can be distinguished through <function>type</function> fields,
         usually in <function>switch</function> statements. The following figure illustrates
	 the concept.	 
	</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="figures/efsd-event.eps" format="eps">
          </imageobject>
          <imageobject>
            <imagedata fileref="figures/efsd-event.gif" format="gif">
          </imageobject>
          <textobject>
            <phrase>Image of EfsdEvent structure</phrase>
          </textobject>
          <caption>
            <para>The <classname>EfsdEvent</classname> Union.</para>
          </caption>
        </mediaobject>

	<para>
	The <classname>EfsdEvent.type</classname> field can be used to determine the kind of event, either
	<constant>EFSD_EVENT_FILECHANGE</constant> or <constant>EFSD_EVENT_REPLY</constant>.
	In the former case, <classname>EfsdEvent.efsd_filechange_event.id</classname> contains
	the command ID that caused this filechange event to be generated <footnote><para>
        Recall that you get the command ID whenever you issue an &efsd; command.</para></footnote>.
	<classname>EfsdEvent.efsd_filechange_event.changetype</classname> describes the type
	of change, with meanings as follows:

	  <itemizedlist mark="opencircle">
	    <listitem>
	      <para>
		<constant>EFSD_FILE_CHANGED</constant> means that the properties of a file,
		as determined through <function>stat()</function>, changed.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		<constant>EFSD_FILE_DELETED</constant> means that a monitored file was
		deleted or renamed.
              </para>
	    </listitem>
	    <listitem>
	      <para>
		<constant>EFSD_FILE_START_EXEC</constant> means that an executable or
		library started executing.
              </para>
	    </listitem>
	    <listitem>
	      <para>
		<constant>EFSD_FILE_STOP_EXEC</constant> means that an executable stopped
		execution.
              </para>
	    </listitem>
	    <listitem>
	      <para>
		<constant>EFSD_FILE_CREATED</constant> means that a file was created in
		a monitored directory.
              </para>
	    </listitem>
	    <listitem>
	      <para>
		<constant>EFSD_FILE_ACKNOWLEDGE</constant> is the confirmation from &efsd;
		that no more events will be received on a monitor that was previously
		stopped, using <link linkend="API-efsd-stop-monitor"><function>efsd_stop_monitor()
		</function></link>.
              </para>
	    </listitem>
	    <listitem>
	      <para>
		<constant>EFSD_FILE_EXISTS</constant> events are received when a file
		is started to be monitored. When the file is a directory and directory
		monitoring was requested, <constant>EFSD_FILE_EXISTS</constant> events
		are received for every file in the directory. Note that by default,
		hidden files (starting with a dot) are excluded.
              </para>
	    </listitem>
	    <listitem>
	      <para>
		<constant>EFSD_FILE_END_EXISTS</constant> means that the client has
		received all <constant>EFSD_FILE_EXISTS</constant> events.
              </para>
	    </listitem>
	  </itemizedlist>

	Finally, <classname>EfsdEvent.file</classname> contains the chanonical name of
	the file on which the event is reported.
	</para>

	<para>
	When <classname>EfsdEvent.type</classname> is <constant>EFSD_EVENT_REPLY</constant>,
	<classname>EfsdEvent.command</classname> contains the command that caused this
	reply event, <classname>EfsdEvent.status</classname> is the outcome (either <constant>
	SUCCESS</constant> or <constant>FAILURE</constant>), <classname>EfsdEvent.errorcode</classname>
	is the value of the <function>errno</function> variable when an error occurred,
	<classname>EfsdEvent.data_len</classname> is the length of any received binary data
	in bytes, and <classname>EfsdEvent.data</classname> is a pointer to the data itself.	
	</para>

        </section>
      </section>

      <section id="monitoring">
	<title id="monitoring.title">Monitoring and Listing Files</title>
	<para>
	  &efsd; allows you to <emphasis>monitor</emphasis> files and directories.
          Monitoring means that your client is notified when files are modified,
          created or removed. You can monitor both single files or entire directories.
	  As described when the <constant>EFSD_FILE_EXIST</constant> event type was
	  introduced, <constant>EFSD_FILE_EXISTS</constant> events are received when a file
          monitor is started, whereas a directory monitor generates <constant>EFSD_FILE_EXISTS
	  </constant> events for every file in the directory. Note that by default,
	  hidden files (starting with a dot) are excluded.

	  <caution>
	    <title> When you monitor a directory as a file, you get <emphasis>no</emphasis>
	      monitoring events when a file in the directory changed.</title>
            <para>
            </para>
	  </caution>
	</para>
	<para>
	  To request monitoring a file, use <link linkend="API-efsd-start-monitor-file">
	  <function>efsd_start_monitor_file()</function></link>. For directories, use
	  <link linkend="API-efsd-start-monitor-dir"><function>efsd_start_monitor_dir()</function></link>,
	  and for stopping a monitor, <link linkend="API-efsd-stop-monitor"><function>
	  efsd_stop_monitor()</function></link>. Make sure you understand the meaning
	  of the various file monitoring events that can occur, recall the Section on
	  <link linkend="eventtypes" endterm="eventtypes.title"></link>.
	</para>
	<para>
	  Because a directory monitor causes potentially a lot of communication traffic
	  (for all the <constant>EFSD_FILE_EXIST</constant> events), it is a good idea
	  to consider passing options along with the command, that launch other commands
	  on every reported file. See <link linkend="options" endterm="options.title"></link>
	  for details.
	</para>
      </section>

      <section>
        <title>Setting and Retrieving File Metadata</title>
          <para>
	  There are a lot of scenarios where it can be useful to attach arbitrary data
	  to a file. Think of coordinates for a file's icon in a file manager etc. In
	  fact, most operating systems already store such <emphasis>metadata</emphasis>
	  for each file, such as modification times, file permissions etc. The problem
	  is that this information is fixed and doesn't allow a user program to attach
	  arbitrary data <footnote><para>Apparently there is a Linux kernel patch in
	  the works that will allow this.</para></footnote>. Whether or not you're
	  using Linux, &efsd; allows you to associate arbitrary information with a file.
	  </para>
	  <para>
	  The API for setting and retrieving file metadata is simple. Every chunk of
	  metadata is identified through a <emphasis>key</emphasis>, which is a simple
	  character string. When setting metadata, you can choose among four types of
	  data:
	  
	  <itemizedlist mark="opencircle">
	    <listitem>
	      <para><constant>EFSD_INT</constant>: integer data.</para>
	    </listitem>
	    <listitem>
	      <para><constant>EFSD_FLOAT</constant>: floating-point data.</para>
	    </listitem>
	    <listitem>
	      <para><constant>EFSD_STRING</constant>: character string data.</para>
	    </listitem>
	    <listitem>
	      <para><constant>EFSD_RAW</constant>: raw binary data.</para>
	    </listitem>
	  </itemizedlist>

	  &lefsd;'s API provides one function for each of these datatypes, those calls are
	  <link linkend="API-efsd-set-metadata-int"><function>efsd_set_metadata_int()</function></link>,
	  <link linkend="API-efsd-set-metadata-float"><function>efsd_set_metadata_float()</function></link>,
	  <link linkend="API-efsd-set-metadata-str"><function>efsd_set_metadata_str()</function></link> and
	  <link linkend="API-efsd-set-metadata-raw"><function>efsd_set_metadata_raw()</function></link>.
	  Those functions should be self-explanatory. When using <link linkend="API-efsd-set-metadata-raw">
	  <function>efsd_set_metadata_raw()</function></link>, you need to pass the type of the data
	  you're setting, also the size of the data chunk in bytes.
          </para>
	  <para>
	  When querying for metadata, use <link linkend="API-efsd-get-metadata"><function>
	  efsd_get_metadata()</function></link>. The client will then get an
	  <classname>EfsdEvent</classname> containing a <classname>EfsdReplyEvent</classname>
	  containing the metadata. You can look up the details of the requested data in
	  them command received along with the reply. To access the type of the metadata
	  and the data itself, &lefsd; provides convenience functions to save you from
	  the tedious traversal of the <classname>EfsdEvent</classname> union. Those are
	  <link linkend="API-efsd-metadata-get-type"><function>efsd_metadata_get_type()</function></link>,
	  <link linkend="API-efsd-metadata-get-int"><function>efsd_metadata_get_int()</function></link>,
	  <link linkend="API-efsd-metadata-get-float"><function>efsd_metadata_get_float()</function></link>,
	  <link linkend="API-efsd-metadata-get-str"><function>efsd_metadata_get_str()</function></link> and
	  <link linkend="API-efsd-metadata-get-raw"><function>efsd_metadata_get_raw()</function></link>,

	  <caution>
	    <title> When using <link linkend="API-efsd-metadata-get-str"><function>
              efsd_metadata_get_str()</function></link> or <link linkend="API-efsd-metadata-get-raw">
              <function>efsd_metadata_get_raw()</function></link>, you need to <function>free()</function>
	      the string/data you receive.
            <para>
	      This is because you get a copy of the data whenever you request it. Regardless of
	      releasing this memory, you still need to call <link linkend="API-efsd-event-cleanup">
	     <function>efsd_event_cleanup()</function></link> on the reply event itself!
            </para>
	  </caution>
	  </para>
	  <para>
          For details about how this feature is implemented, see
	  <link linkend="efsd-meta" endterm="efsd-meta.title"></link>.									   
	  </para>
      </section>

      <section>
        <title>Handling Filetypes</title>
	  <para>
	  </para>
      </section>

      <section>
        <title>Other File Commands</title>
	  <para>
	  </para>
      </section>

      <section id="options">
	<title id="options.title">Passing Command Options</title>
	<para>
	  Many of the most commonly used commands at the command line use
	  options, think of <command>ls -la</command>, <command>mkdir -p</command>
	  etc. &lefsd; provides a flexible way of combining options for the same purpose.
          Also, the ability to pass options can be a great performance
          improvement: consider the case where monitoring a large directory is requested.
          Chances are that an application will need to initialize data structures
          according to the various <constant>EFSD_FILE_EXISTS</constant> events, and
          that the application will send further commands to &efsd; based on those events.
          By requesting those actions to be taken by passing a single option to the original
          file monitoring request, the communication overhead can be drastically reduced,
          because the request is sent only once, instead of once <emphasis>per
          received <constant>EFSD_FILE_EXISTS</constant> event</emphasis>.
	</para>
	<para>
	  There are two conceivable situations when you encounter the need
	  for options:

	  <itemizedlist mark="opencircle">
	    <listitem>
	      <para>Static combinations of options, known at compile time.</para>
	    </listitem>
	    <listitem>
	      <para>Dynamic combinations of options, unknown at compile time.</para>
	    </listitem>
	  </itemizedlist>
	  
	  Consequently, &lefsd; provides two means for plugging options together. All
          options are constructed using the <function>efsd_op_XXX()</function> calls. For
	  the static case, there's the <link linkend="API-efsd-ops"><function>efsd_ops()
	  </function></link> function, which is variadic. You pass it the number of options
          you are using, and then call the needed option constructors. An example:

	  <programlisting>  
EfsdConnection *ec;
EfsdCmdId id;
EfsdOptions *ops;

/* Connection setup, etc. */

/* Assemble an EfsdOptions structure, containing 2 options:
 * one to list all files (as in ls -a), and one to request
 * alphabetical sorting of the listed files.
 */

ops = efsd_ops(2, efsd_op_list_all(), efsd_op_sort());

/* Now simply pass ops along with the command: */

if ( (id = efsd_listdir(ec, "foo/bar", ops)) < 0)
  {
     /* Could not send command. Continue accordingly. */
  }
	  </programlisting>

	  <caution>
	    <title>You do not need to <function>free()</function> the options.</title>
            <para>
              The <classname>EfsdOptions</classname> are already deallocated by the time
              the &efsd; command returns.
            </para>
	  </caution>

	  The other case is when you need to assemble options dynamically, at runtime
	  <footnote><para><link linkend="efsdshell">&efsdsh;</link> is an example of an application
          where this happens.</para></footnote>. Just create an <classname>EfsdOptions</classname>
          structure using <function>efsd_ops_create()</function>, and then add options created via
          <function>efsd_op_XXX()</function> using <function>efsd_ops_add()</function>.

	  <programlisting>  
EfsdConnection *ec;
EfsdCmdId id;
EfsdOptions *ops;
int show_all, get_stat, get_type, sort;

/* Connection setup, etc. */

/* Determine which options are needed (I assume here
 * that there's at least one), and set the corresponding
 * flags (show_all, get_stat etc).
*/

ops = efsd_ops_create();

if (show_all) efsd_ops_add(ops, efsd_op_list_all());
if (get_stat) efsd_ops_add(ops, efsd_op_get_stat());
if (get_type) efsd_ops_add(ops, efsd_op_get_filetype());
if (sort)     efsd_ops_add(ops, efsd_op_sort());

if ( (id = efsd_start_monitor_dir(ec, "/some/dir", ops)) < 0)
  {
     /* Could not send command. Continue accordingly. */
  }
	  </programlisting>
        <note>
	  <title>If you don't want to give any options, just pass NULL as <classname>EfsdOptions</classname>.</title>
	  <para></para>
	</note>
	
	</para>
	<para>
        When using options on a file monitoring request (like <link linkend="API-efsd-start-monitor-dir">
        <function>efsd_start_monitor_dir()</function></link>), you are guaranteed to receive
        the <constant>EFSD_FILE_EXISTS</constant> events before any results of options applied
	to the files that are covered by the monitor. You can <emphasis>not</emphasis>, however,
        rely on receiving the <constant>EFSD_FILE_EXISTS</constant> events and all the results
	generated through the options before receiving the <constant>EFSD_FILE_EXISTS</constant>
        event for the next file, or on any sequence in which those results arrive. The reason
        is that the actions requested by the options take varying amounts of time and
        &efsd; processes those actions in parallel. See
        <link linkend="multithreading" endterm="multithreading.title"></link> for details.
	</para>
      </section>

    </section>

    <section>
      <title>&lefsd; API Documentation</title>
!I@toplevel_abs@/efsd/libefsd.h
    </section>
  </chapter>

  <chapter id="efsd">
    <title id="efsd.title">&efsd; - The Server Side</title>
      <note>
        <title>This Chapter explains the inner workings of the &efsd; daemon.</title>
        <para>
	  It will be of interest primarily to people who want to hack on the code
          and/or understand how &efsd; works internally. You can easily use &efsd; without
          reading this chapter.
       </para>
      </note
    <section>
      <title>Tour of the Source Files</title>
      <para>
         The purpose of this section is to give a quick overview of what's contained
         in the source files (contained in the <function>/efsd</function> subdirectory).
         The following naming scheme is used throughout the code:

	<itemizedlist mark="opencircle">
	  <listitem>
	    <para>Every non-static function has the prefix <function>efsd_</function>.</para>
	  </listitem>
	  <listitem>
	    <para>All functions declared in the same header file have the same sub-prefix
	      (e.g., every function declared in <function>efsd_monitor.h</function> begins
	      with <function>efsd_monitor_</function>). This should make it easy enough
	      to quickly find things even on a first read.
	    </para>
	  </listitem>
	  <listitem>
	    <para>Static functions use the same sub-prefix, but don't have the
	      <function>efsd_</function> prefix.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>
    </section>
    <section id="efsd-ipc">
      <title id="efsd-ipc.title">IPC mechanisms</title>
      <para>
      </para>
    </section>
    <section id="efsd-filetypes">
      <title id="efsd-filetypes.title">Filetype Module</title>
      <para>
      </para>
    </section>
    <section id="efsd-commands">
      <title id="efsd-commands.title">File Commands Module</title>
      <para>
      </para>
    </section>
    <section id="efsd-meta">
      <title id="efsd-meta.title">Metadata Module</title>
      <para>
      </para>
    </section>
    <section>
      <title>Stat Cache</title>
      <para>
      </para>
    </section>
    <section>
      <title>File Monitoring Module</title>
      <para>
      </para>
    </section>
    <section>
      <title>Advanced Data Structures</title>
      <para>
      </para>
    </section>
    <section id="multithreading">
      <title id="multithreading.title">Multithreaded Implementation</title>
      <para>
      </para>
    </section>
    <section>
      <title>To Do</title>
      <para>
	Well, software is never finished, and this also applies to &efsd;. You can always look at the
	TODO file in CVS to see what's currently missing. Patches are appreciated, please send them
	to the author at <email>cK@whoop.org</email>. At the time of this writing, the following things
	are missing:

	<itemizedlist mark="opencircle">
	  <listitem>
	    <para>A thorough testsuite, especially for the cache interaction and the
	      functions in <filename>efsd_fs.c</filename>, i.e. the file copy/move/remove
	      code. Ideally this would be an automated set of tests to check if changes
	      broke anything. Think XP.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      A great feature would be to not only get the filetypes in a MIME type-ish notation,
	      but also in fully human-readable form (sort of like the file(1) output). Ideally
	      this would include internationalization and localization support.
	    </para>
	  </listitem>
	</itemizedlist>

      </para>
    </section>
  </chapter>

  <chapter id="efsdshell">
    <title>&efsdsh; - An Interactive &efsd; Client</title>
    <para>    	     
      The &efsd; distribution comes with a useful tool for testing and playing with &efsd;
      -- that's &efsdsh;, the &efsd; shell <footnote><para>"Shell" is a bit of exageration, since &efsdsh;
      provides only a small subset of a real shell's functionality.</para></footnote>. It provides
      a simplified command line prompt, where you can send commands to &efsd; in the usual fashion, i.e.
      a directory copy command is <function>cp -r /some/dir /some/other/dir</function> etc.
      Enter <function>help</function> at the prompt to get an overview of the available commands and
      options.
    </para>
    <para>
      Besides being useful for testing &efsd; commands, &efsdsh; is also great for testing &efsd;'s
      behaviour when handling multiple clients - just launch a bunch of &efsdsh;s and watch how
      file monitoring requests are answered in a few of them etc.
    </para>
    <para>
      Notice that &efsd; must be running when starting &efsdsh;, it does not do that for you.
    </para>
  </chapter>
  
  <chapter id="summary">
    <title>Summary</title>
    <para>
    </para>
  </chapter>
  
  <bibliography>

    <biblioentry id="bib-unp">
      <bookbiblio>
	<author>	  
	  <firstname>W. R.</firstname>
	  <surname>Stevens</surname>
	</author>
	<title>UNIX Network Programming</title>
	<edition>Second Edition</edition>
	<volumenum>Volume 1</volumenum>
	<publisher>
	  <publishername>Prentice-Hall</publishername>
	</publisher>
	<date>1998</date>
      </bookbiblio>
    </biblioentry>	
      
    <biblioentry id="bib-apue">
      <bookbiblio>
	<author>
	  <firstname>W. R.</firstname>
	  <surname>Stevens</surname>
	</author>
	<title>Advanced Programming in the UNIX Environment</title>
	<publisher>
	  <publishername>Addison-Wesley</publishername>
	</publisher>
	<date>1992</date>
      </bookbiblio>
    </biblioentry>	

  </bibliography>
      
</book>

