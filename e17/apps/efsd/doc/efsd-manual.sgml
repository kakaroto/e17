<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V3.1//EN" [
<!ENTITY efsd "<function>efsd</function>">
<!ENTITY lefsd "<function>libefsd</function>">
<!ENTITY efsdsh "<function>efsdsh</function>">
]>


<book id="efsd-manual">
  <bookinfo>
    <title>The EFSD Programming Manual</title>
    
    <authorgroup>
      <author>
	<firstname>Christian</firstname>
	<othername></othername>
	<surname>Kreibich</surname>
	<affiliation>
	  <address>
	    <email>cK@whoop.org</email>
	  </address>
	</affiliation>
      </author>
    </authorgroup>
    
    <copyright>
      <year>2001</year>
      <holder>Christian Kreibich</holder>
    </copyright>
    
    <legalnotice>
      <para>
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to
	deal in the Software without restriction, including without limitation the
	rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	sell copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
      </para>
      <para>
	The above copyright notice and this permission notice shall be included in
	all copies of the Software and its documentation and acknowledgment shall be
	given in the documentation and software packages that this Software was
	used.
      </para>
      <para>
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
	THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
	IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
      </para>
    </legalnotice>

    <releaseinfo>
      This is document is nowhere near being finished. Be patient.
    </releaseinfo>
    
  </bookinfo>

  <toc></toc>

  <chapter id="introduction">
    <title>Introduction</title>
    <para>
      This is the manual for &efsd;, the Enlightenment File System Daemon.
      The purpose of &efsd; is to provide a facility that allows applications
      to issue commands on filesystems (such as the familiar <command>cp</command>,
      <command>mv</command> and <command>rm</command>, but much more than that)
      in a non-blocking fashion
      and get reports on the outcome of those commands asynchronously.      
    </para>
    <para>
      If you're not sure why this is a good thing, read
      <link linkend="why" endterm="why.title"></link>. If you want to jump right
      in, Chapter <link linkend="libefsd" endterm="libefsd.title"></link> has
      the gory details of using &lefsd;. If you want to go even further and read
      the code, Chapter <link linkend="efsd" endterm="efsd.title"></link> is the
      thing for you.
    </para>
    <para>
      This manual can always be downloaded at
      <ulink url="http://www.whoop.org/downloads/efsd-manual.tgz">whoop.org</ulink>.
    </para>
    <para>
      I'd like to thank Raster <email>raster@rasterman.com</email> for talking
      me into writing &efsd; during one of our dinner sessions somewhere in San
      Francisco in late 2000. I've had and am still having a blast working on it.
      I'd also like to thank the various people who have contributed suggestions,
      feedback and patches. Their names can always be found in the
      <filename>AUTHORS</filename> file.
    </para>
  </chapter>

  <chapter id="overview">
    <title id="overview.title">Overview of &efsd;</title>
    <section id="why">
      <title id="why.title">Why use it?</title>
      <para>
	Assume the following situation: you're writing an application that needs
	to perform typical filesystem-related tasks, possibly multiple ones at the
	same time, such as copying or moving files (see the list of commands in
	Section <link linkend="sending-commands" endterm="sending-commands.title"></link>)
	which may consume a lot of time. Additionally, the application needs to
	stay responsive to user input and/or other events while these commands
	are executed.	
      </para>
      <para>
	A possible solution is to code the needed functionality and make it run in
	separate threads. This is both a duplication of effort and can also quickly
	become nontrivial from a synchronization point of view.
      </para>
      <para>
	Enter &efsd;. &efsd gives you all the functionality mentioned above,
	accessible through a simple API, in an efficient, parallelized implementation.
	&efsd; integrates many commonly needed filesystem commands in one software
	package. See Section <link linkend="using-efsd" endterm="using-efsd.title"></link>
	for details about enabling your application to use &efsd; and Section
	<link linkend="efsd-arch" endterm="efsd-arch.title"></link> to get an
	idea about the way &efsd works.
      </para>
    </section>
    <section id="using-efsd">
      <title id="using-efsd.title">Using &efsd; in Your Application</title>
      <para>
	What is usually referred to as &efsd; actually comes in two parts -
        the &efsd; server daemon and a library to be used by the clients, called
        &lefsd;. When referring to the software package &efsd;, the combination
        of both the server and the library is meant. Context should make clear
	what is referred to.
      </para>
      <para>
        To enable your application to use &efsd;, all you have to
        do is link your application against &lefsd;. In the tradition of
	the various configuration scripts that lots of software packages
	are providing now (think of <command>gtk-config</command>,
	<command>gnome-config</command> etc), &efsd; has
        <command>efsd-config</command>, which reports the necessary compilation
        and linkage flags.
      </para>
      <para>
        When running your application, the &efsd; daemon must be up and running.
        You can do this by simply issuing the <command>efsd</command> command (see
        <command>efsd --help</command> for the available options), or your
        application can launch it for you (although it should do so only after
        making sure that an &efsd; instance isn't already running).
      </para>
      <para>
        &efsd; has a few requirements. Right now they are

	<itemizedlist mark="opencircle">
	  <listitem>
	    <para>
              FAM, the File Alteration Monitor, available at
              <ulink url="http://oss.sgi.com/projects/fam">SGI's Open Source site</ulink>.
            </para>
	    <para>
              FAM is used to implement &efsd;'s file monitoring.
            </para>
          </listitem>
	  <listitem>
	    <para>
              Edb, the Enlightenment Database, based on BerkeleyDB. It's available on
              Enlightenment's SourceForge 
              <ulink url="http://prdownloads.sourceforge.net/enlightenment">download page</ulink>.
            </para>
	    <para>
              Edb is used to implement &efsd;'s file metadata handling.
            </para>
          </listitem>
	  <listitem>
	    <para>
	      libxml2, available at
              <ulink url="http://www.xmlsoft.org">XMLSoft</ulink>.
            </para>
	    <para>
              &efsd; uses libxml2 to store the filetype database.
            </para>
          </listitem>
	</itemizedlist>
      </para>
    </section>
    <section id="getting-efsd">
      <title id="getting-efsd.title">Getting &efsd;</title>
      <para>
	At the time of this writing, there has not been a release yet, although the current
	codebase is definitely ready for one. You can always get up-to-date sources from
	Enlightenment's CVS tree, see
	<ulink url="http://www.sourceforge.net/projects/enlightenment">Enlightenment's SourceForge site</ulink>.
      </para>
    </section>
    <section id="efsd-arch">
      <title id="efsd-arch.title">&efsd; Architecture Overview</title>
      <para>
	The purpose of this section is to give an overview of the general architecture of &efsd;,
	and to give the user an idea of how it works.
      </para>
	  
      <mediaobject>
        <imageobject>
          <imagedata fileref="figures/architecture.eps" format="eps">
        </imageobject>
        <imageobject>
          <imagedata fileref="figures/architecture.gif" format="gif">
        </imageobject>
        <textobject>
          <phrase>Image of &efsd; Architecture</phrase>
        </textobject>
        <caption>
          <para>&efsd; Architecture.</para>
        </caption>
      </mediaobject>

      <para>
        As can be seen above, multiple clients talk to &efsd; through &lefsd;. &efsd; in turn
	is composed of a number of subsystems which handle command-specific tasks, accessing the
	filesystem through system calls as well as <function>libfam</function> and <function>FAM</function>,
        the File Alteration Monitor (available at <ulink url="http://oss.sgi.com/projects/fam">
	<citetitle>SGI's oss site</citetitle></ulink>), for <link linkend="monitoring">monitoring of files</link>.
      </para>

      <para>
	To use &efsd;, applications establish a communication channel with &efsd
	using &lefsd;.  Using this connection, they then send commands to the
	daemon, which starts to execute them upon reception. When execution is
	finished, a reply containing details such as the result of the operation
        is asynchronously sent back to the client application, which was able
	to continue work on other outstanding tasks in the meantime.
    </section>
  </chapter>

  <chapter id="libefsd">
    <title id="libefsd.title">&lefsd; - The Client Side of &efsd;</title>
    <section>
      <title>Using &lefsd;</title>
      <para>
	The way applications talk to &efsd; is through
	&lefsd;. &lefsd; handles
	all the dirty low-level work (such as the I/O details of sending commands
	and receiving replies) and provides a convenient API to the clients.
	The following sections introduce general concepts before the API is
	explained in detail.

	<note>
	  <title>This chapter tells you all you'll need to know in order to use
	    use the &lefsd; API.</title>
	  <para>
	    The next chapter gives additional information about the server itself,
	    but that information is not strictly necessary in order to be able
	    to use &efsd;, except maybe for the command line options when launching
	    the server.
	  </para>
	</note
      </para>
      <section>
	<title>Opening a Connection to &efsd;</title>
	<para>
	  Before you can launch any commands, you need to establish a
	  connection to &efsd; via <link linkend="API-efsd-open">
	    <function>efsd_open()</function></link>. The returned
	  &efsd; pointer is used to identify the connection and is passed as
	  first parameter to basically every function. When you're done, you can tear down the connection
	  and release the allocated memory using <link linkend="API-efsd-close">
	    <function>efsd_close()</function></link>.
	  <programlisting>

EfsdConnection *ec;

if ( (ec = efsd_open()) == NULL)
  {
     /* Oops. Couldn't establish connection.
      * Is Efsd really running ? 
      */
  }

/* ... various efsd commands ... */

if (efsd_close(ec) < 0)
  {
     /* Ouch. Error when closing connection. */
  }
	  </programlisting>
	</para>
      </section>
      <section id="sending-commands">
	<title id="sending-commands.title">Sending Commands</title>
	<para>
	  After opening a connection, the client is ready to launch commands.
	  You can send commands for the following tasks:

	  <itemizedlist mark="opencircle">
	    <listitem>
	      <para>Copying, moving, removing files and directories(<function>cp</function>,
		<function>mv</function>, <function>rm</function>)</para>
	    </listitem>
	    <listitem>
	      <para>Creating directories (<function>mkdir</function>)</para>
	    </listitem>
	    <listitem>
	      <para>Creating symbolic links (<function>ln -s</function>)</para>
	    </listitem>
	    <listitem>
	      <para>Getting the target of a link (<function>readlink</function>)</para>
	    </listitem>
	    <listitem>
	      <para>Setting permissions (<function>chmod</function>)</para>
	    </listitem>
	    <listitem>
	      <para>Listing directory contents (<function>ls</function>)</para>
	    </listitem>
	    <listitem>
	      <para>Setting and getting metadata</para>
	    </listitem>
	    <listitem>
	      <para>Getting filetype information</para>
	    </listitem>
	    <listitem>
	      <para><function>stat</function> and <function>lstat</function></para>
	    </listitem>
	    <listitem>
	      <para>File monitoring</para>
	    </listitem>
	  </itemizedlist>
	  
	  When a command is sent to the server, you get a (non-negative) command ID in
	  return, which is guaranteed to be unique, and can therefore be
	  used to associate replies from &efsd; and
	  sent commands. The exception is the unlikely case that the
	  write buffer from the client to the server does not have enough
	  room for the command, in this case a value &lt; 0 is returned.
	  This is rather unlikely, however, robust code should always
	  check the result like this:

	  <programlisting>

EfsdConnection *ec;
EfsdCmdId id;

if ( (ec = efsd_open()) == NULL)
  {
     /* Oops. Couldn't establish connection.
      * Is Efsd really running ?
      */
  }

if ( (id = efsd_makedir(ec, "foo/bar")) < 0)
  {
     /* Could not send command. Continue accordingly. */
  }
	  </programlisting>

	  <note>
	    <title>A return value &lt; 0 does not mean that an error occurred when processing the command.</title>
	    <para>
	      It means that the command didn't get sent to the server in the
	      first place. Errors during actual execution of the commands are
	      reported as error codes in the returned replies.
	    </para>
	  </note>
	</para>	
	<para><
	  If you don't check the return value, the receiving part of your client
	  may be waiting for reply to a command that never got sent to &efsd;.
	</para>
	<para>
	  When clients send bursts of commands, it can happen that &efsd; is busy
	  processing commands and cannot keep up with the commands being sent to
	  the server. When this happens, commands are queued on the client side.
	    &lefsd; offers two calls to handle the client-side command queues:
	  <link linkend="API-efsd-commands-pending"><function>efsd_commands_pending()</function></link>,
	  which reports whether or not commands are currently queued, and 
	  <link linkend="API-efsd-flush"><function>efsd_flush()</function></link>,
          which sends as many queued commands to the client as possible.
	</para>
	<para>
	  The queue is also processed whenever a command is written to the server,
	  so the command sequence always remains intact.
	</para>
	<para>
	  The ideal way to manually flush the queue (in case there is one), is to
	  get the &efsd; connection file descriptor using
	  <link linkend="API-efsd-get-connection-fd"><function>efsd_get_connection_fd()</function></link>,
	  then to use <function>select()</function> on the file descriptor to
	  find out when it becomes writeable, and then flush the queue.
	</para>
      </section>
      
      <section>
	<title>Receiving Events</title>
        <para>
	  There are two basic ways of receiving events from &efsd; in your client:
	  Using <function>select()</function> to wait on events on file descriptors,
	  or using &lefsd;'s convenience functions which block and wait until events
	  arrive.
        </para>
	<section>
	  <title>Using <function>select()</function> and File Descriptors</title>
          <para>
	  This is the more sophisticated and flexible way, well-suited for complex
	  event loops. Use <link linkend="API-efsd-get-connection-fd"><function>
	  efsd_get_connection_fd()</function></link> to get the connection's file
	  descriptor. You can then <function>ioctl()</function> this descriptor to
	  enable e.g. nonblocking mode, then use <function>select()</function> as
	  usual. If you're not familiar with <function>select()</function>, have a
	  look at <link linkend="bib-apue"><citation>Stevens 1998</citation></link> or
	  <link linkend="bib-unp"><citation>Stevens 1992</citation></link>.
          </para>
	  <para>
	    The code in this case then usually looks like this:

	  <programlisting>  
EfsdConnection *ec;
fd_set          fdset;
int             fd, fdsize = 0;

if ( (ec = efsd_open()) == NULL)
  {
     /* Oops. Couldn't establish connection.
      * Is Efsd really running ?
      */
  }

fd = efsd_get_connection_fd(ec);

FD_ZERO(&amp;fdset);

/* Set desired filedescriptors here, also maybe
 * create other fd_sets ...
 */

/* ... */

FD_SET(fd, &amp;fdset);
if (fd > fdsize)
  fdsize = fd;

select(fdsize + 1, &amp;fdset, NULL, NULL, NULL);

/* Check for events on Efsd's descriptor */

if (FD_ISSET(fd, &amp;fdset))
  {	  
    EfsdEvent ee;

    /* Efsd events have arrived -- now loop while
     * there are events pending in the arrival queue.
     */
   
    while (efsd_events_pending(ec))
      {
	 if (efsd_next_event(ec, &amp;ee) >= 0)
           {
              /* Handle the event */
	      /* ... */

              /* Now clean up: */
              efsd_event_cleanup(&amp;ee);
           }
	 else
           {
              /* Error while reading event. */
           }
      }
  }
	    </programlisting>
	    After adding the file descriptors to an <classname>fd_set</classname>,
            you <function>select()</function> the <classname>fd_set</classname>
            and check &efsd;'s file descriptor when <function>select()</function> returns.
	    One or more &efsd; events may have arrived. To read them, loop while
	    <link linkend="API-efsd-events-pending"><function>efsd_events_pending()
	    </function></link> returns a value greater than zero. You read the event
            into an <classname>EfsdEvent</classname> structure.

	  <caution>
	    <title>After you finished handling the event, you need to clean up the structure.</title>
            <para>
              Use <link linkend="API-efsd-event-cleanup"><function>efsd_event_cleanup()</function></link>
              to release any memory that was read into the <classname>EfsdEvent</classname> structure.
            </para>
	  </caution>
	  </para>
        </section>
	<section>
	  <title>Using &lefsd; and Blocking Waits</title>
          <para>
	    When you're not using complex event loops, a simpler way is to use
	    &lefsd;'s convenience functions for reading &efsd; events. The code
	    looks like this:

	  <programlisting>  
EfsdConnection *ec;
EfsdEvent ee;

if ( (ec = efsd_open()) == NULL)
  {
     /* Oops. Couldn't establish connection.
      * Is Efsd really running ?
      */
  }

while (efsd_wait_event(ec, &amp;ee) >= 0)
  {
     /* Handle the event */
     /* ... */

     /* Now clean up: */
     efsd_event_cleanup(&amp;ee);
  }
	  </programlisting>

	    After establishing the connection to &efsd; your event handler simply
            sits in a loop that calls <link linkend="API-efsd-wait-event">
	    <function>efsd_wait_event()</function></link> and blocks until an event
	    arrives . As before, after handling the event,
	    you need to clean up using <link linkend="API-efsd-event-cleanup"><function>
            efsd_event_cleanup()</function></link>.
          </para>
        </section>

	<section id="eventtypes">
	  <title id="eventtypes.title">Handling Event Types</title>
          <para>
	There are two kinds of reply events that you can receive:

	  <itemizedlist mark="opencircle">
	    <listitem>
	      <para>
                <emphasis>Reply Events</emphasis>, which report the result of a
	        command that was sent to &efsd;. There exist subtypes for the various
                kinds of replies that different commands require.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
                <emphasis>Filechange Events</emphasis>, which report that an
	        aspect of a monitored file has changed (more about file monitoring
                in Section <link linkend="monitoring" endterm="monitoring.title"></link>).
              </para>
	    </listitem>
	  </itemizedlist>

         An <classname>EfsdEvent</classname> is a union of the possible event
	 types, and can be distinguished through <function>type</function> fields,
         usually in <function>switch</function> statements. The following figure illustrates
	 the concept.	 
	</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="figures/efsd-event.eps" format="eps">
          </imageobject>
          <imageobject>
            <imagedata fileref="figures/efsd-event.gif" format="gif">
          </imageobject>
          <textobject>
            <phrase>Image of EfsdEvent structure</phrase>
          </textobject>
          <caption>
            <para>The <classname>EfsdEvent</classname> Union.</para>
          </caption>
        </mediaobject>

	<para>
	The <classname>EfsdEvent.type</classname> field can be used to determine the kind of event, either
	<constant>EFSD_EVENT_FILECHANGE</constant> or <constant>EFSD_EVENT_REPLY</constant>.
	In the former case, <classname>EfsdEvent.efsd_filechange_event.id</classname> contains
	the command ID that caused this filechange event to be generated <footnote><para>
        Recall that you get the command ID whenever you issue an &efsd; command.</para></footnote>.
	<classname>EfsdEvent.efsd_filechange_event.changetype</classname> describes the type
	of change, with meanings as follows:

	  <itemizedlist mark="opencircle">
	    <listitem>
	      <para>
		<constant>EFSD_FILE_CHANGED</constant> means that the properties of a file,
		as determined through <function>stat()</function>, changed.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		<constant>EFSD_FILE_DELETED</constant> means that a monitored file was
		deleted or renamed.
              </para>
	    </listitem>
	    <listitem>
	      <para>
		<constant>EFSD_FILE_START_EXEC</constant> means that an executable or
		library started executing.
              </para>
	    </listitem>
	    <listitem>
	      <para>
		<constant>EFSD_FILE_STOP_EXEC</constant> means that an executable stopped
		execution.
              </para>
	    </listitem>
	    <listitem>
	      <para>
		<constant>EFSD_FILE_CREATED</constant> means that a file was created in
		a monitored directory.
              </para>
	    </listitem>
	    <listitem>
	      <para>
		<constant>EFSD_FILE_ACKNOWLEDGE</constant> is the confirmation from &efsd;
		that no more events will be received on a monitor that was previously
		stopped, using <link linkend="API-efsd-stop-monitor"><function>efsd_stop_monitor()
		</function></link>.
              </para>
	    </listitem>
	    <listitem>
	      <para>
		<constant>EFSD_FILE_EXISTS</constant> events are received when a file
		is started to be monitored. When the file is a directory and directory
		monitoring was requested, <constant>EFSD_FILE_EXISTS</constant> events
		are received for every file in the directory. Note that by default,
		hidden files (starting with a dot) are excluded.
              </para>
	    </listitem>
	    <listitem>
	      <para>
		<constant>EFSD_FILE_END_EXISTS</constant> means that the client has
		received all <constant>EFSD_FILE_EXISTS</constant> events.
              </para>
	    </listitem>
	  </itemizedlist>

	Finally, <classname>EfsdEvent.file</classname> contains the canonical name of
	the file on which the event is reported.
	</para>

	<para>
	When <classname>EfsdEvent.type</classname> is <constant>EFSD_EVENT_REPLY</constant>,
	<classname>EfsdEvent.command</classname> contains the command that caused this
	reply event, <classname>EfsdEvent.errorcode</classname> is the result (a value of 0
	means the operation was completed successfully, otherwise the field contains the
	value of the <function>errno</function> variable and can be processed using
	<function>strerror</function> etc) of the command,
	<classname>EfsdEvent.data_len</classname> is the length of any received binary data
	in bytes, and <classname>EfsdEvent.data</classname> is a pointer to the data itself.	
	</para>

        </section>
      </section>

      <section id="fileops">
        <title id="fileops.title">Copying/Moving/Renaming Files</title>
	<para>
	Besides file monitoring, basic file copying, moving and renaming are probably
	among the most commonly needed file system operations. &efsd; provides
	<link linkend="API-efsd-copy"><function>efsd_copy()</function></link> for
	file copying,
	<link linkend="API-efsd-move"><function>efsd_move()</function></link> for
	moving files and
	<link linkend="API-efsd-remove"><function>efsd_remove()</function></link> for
	deleting files.
	</para>
	<para>
	You can pass multiple file names to all of those commands.
	When using <link linkend="API-efsd-copy"><function>efsd_copy()</function></link> or
	<link linkend="API-efsd-move"><function>efsd_move()</function></link>, the
	last file has to be a directory, and the commands cause all previous files
	to be copied/moved into the target directory. Meaningful options are the
	ones commonly used on the command line, namely
	<link linkend="API-efsd-op-force"><function>efsd_op_force()</function></link> and
	<link linkend="API-efsd-op-recursive"><function>efsd_op_recursive()</function></link>
	for <link linkend="API-efsd-copy"><function>efsd_copy()</function></link> and
	<link linkend="API-efsd-remove"><function>efsd_remove()</function></link>, and
	<link linkend="API-efsd-op-force"><function>efsd_op_force()</function></link> for
	<link linkend="API-efsd-move"><function>efsd_move()</function></link>.
	</para>
      </section>

      <section id="monitoring">
	<title id="monitoring.title">Monitoring and Listing Files</title>
	<para>
	  &efsd; allows you to <emphasis>monitor</emphasis> files and directories.
          Monitoring means that your client is notified when files are modified,
          created or removed. You can monitor both single files or entire directories.
	  As described when the <constant>EFSD_FILE_EXIST</constant> event type was
	  introduced, <constant>EFSD_FILE_EXISTS</constant> events are received when a file
          monitor is started, whereas a directory monitor generates <constant>EFSD_FILE_EXISTS
	  </constant> events for every file in the directory. Note that by default,
	  hidden files (starting with a dot) are excluded.

	  <caution>
	    <title> When you monitor a directory as a file, you get <emphasis>no</emphasis>
	      monitoring events when a file in the directory changed.</title>
            <para>
            </para>
	  </caution>
	</para>
	<para>
	  To request monitoring of a file or directory, use <link linkend="API-efsd-start-monitor">
	  <function>efsd_start_monitor()</function></link>, for stopping a monitor, use
	  <link linkend="API-efsd-stop-monitor"><function>efsd_stop_monitor()</function></link>.
	  Make sure you understand the meaning of the various file monitoring events that can occur,
	  recall the section on <link linkend="eventtypes" endterm="eventtypes.title"></link>.
	</para>
	<para>
	  The same event-based technique for getting the directory contents can also be
	  used to just get a directory listing, using <link linkend="API-efsd-listdir">
          <function>efsd_listdir()</function></link>. It causes <constant>EFSD_FILE_EXIST</constant>
	  events to be sent to the requesting client just like when a full monitor is
	  requested. You do not, however, get events when files in the directory are
	  changed afterwards.
	</para> 
	<para>
	  Because a directory monitor and a directory listing potentially cause a lot of
	  communication traffic (for all the <constant>EFSD_FILE_EXIST</constant> events),
	  it is a good idea to consider passing options along with the command, that launch other commands
	  on every reported file. See <link linkend="options" endterm="options.title"></link>
	  for details.
	</para>
      </section>

      <section>
        <title>Setting and Retrieving File Metadata</title>
          <para>
	  There are a lot of scenarios where it can be useful to attach arbitrary data
	  to a file. Think of coordinates for a file's icon in a file manager etc. In
	  fact, most operating systems already store such <emphasis>metadata</emphasis>
	  for each file, such as modification times, file permissions etc. The problem
	  is that this information is fixed and doesn't allow a user program to attach
	  arbitrary data <footnote><para>Apparently there is a Linux kernel patch in
	  the works that will allow this.</para></footnote>. Whether or not you're
	  using Linux, &efsd; allows you to associate arbitrary information with a file.
	  </para>
	  <para>
	  The API for setting and retrieving file metadata is simple. Every chunk of
	  metadata is identified through a <emphasis>key</emphasis>, which is a simple
	  character string. When setting metadata, you can choose among four types of
	  data:
	  
	  <itemizedlist mark="opencircle">
	    <listitem>
	      <para><constant>EFSD_INT</constant>: integer data.</para>
	    </listitem>
	    <listitem>
	      <para><constant>EFSD_FLOAT</constant>: floating-point data.</para>
	    </listitem>
	    <listitem>
	      <para><constant>EFSD_STRING</constant>: character string data.</para>
	    </listitem>
	    <listitem>
	      <para><constant>EFSD_RAW</constant>: raw binary data.</para>
	    </listitem>
	  </itemizedlist>

	  &lefsd;'s API provides one function for each of these data types, those calls are
	  <link linkend="API-efsd-set-metadata-int"><function>efsd_set_metadata_int()</function></link>,
	  <link linkend="API-efsd-set-metadata-float"><function>efsd_set_metadata_float()</function></link>,
	  <link linkend="API-efsd-set-metadata-str"><function>efsd_set_metadata_sir()</function></link> and
	  <link linkend="API-efsd-set-metadata-raw"><function>efsd_set_metadata_raw()</function></link>.
	  Those functions should be self-explanatory. When using <link linkend="API-efsd-set-metadata-raw">
	  <function>efsd_set_metadata_raw()</function></link>, you need to pass the type of the data
	  you're setting, also the size of the data chunk in bytes.
          </para>
	  <para>
	  When querying for metadata, use <link linkend="API-efsd-get-metadata"><function>
	  efsd_get_metadata()</function></link>. The client will then get an
	  <classname>EfsdEvent</classname> containing a <classname>EfsdReplyEvent</classname>
	  containing the metadata. You can look up the details of the requested data in
	  them command received along with the reply. To access the type of the metadata
	  and the data itself, &lefsd; provides convenience functions to save you from
	  the tedious traversal of the <classname>EfsdEvent</classname> union. Those are
	  <link linkend="API-efsd-metadata-get-type"><function>efsd_metadata_get_type()</function></link>,
	  <link linkend="API-efsd-metadata-get-int"><function>efsd_metadata_get_int()</function></link>,
	  <link linkend="API-efsd-metadata-get-float"><function>efsd_metadata_get_float()</function></link>,
	  <link linkend="API-efsd-metadata-get-str"><function>efsd_metadata_get_str()</function></link> and
	  <link linkend="API-efsd-metadata-get-raw"><function>efsd_metadata_get_raw()</function></link>,

	  <caution>
	    <title> When using <link linkend="API-efsd-metadata-get-str"><function>
              efsd_metadata_get_str()</function></link> or <link linkend="API-efsd-metadata-get-raw">
              <function>efsd_metadata_get_raw()</function></link>, you need to <function>free()</function>
	      the string/data you receive.
            <para>
	      This is because you get a copy of the data whenever you request it. Regardless of
	      releasing this memory, you still need to call <link linkend="API-efsd-event-cleanup">
	     <function>efsd_event_cleanup()</function></link> on the reply event itself!
            </para>
	  </caution>
	  </para>
      </section>

      <section id="filetypes">
        <title id="filetypes.title">Handling Filetypes</title>
        <para>
	  Oftentimes, an application wants to know details about a file it needs to read or
	  modify. GUI environments frequently create security risks when simplistic
	  mechanisms are used to associate files and applications working on those files.
	  Usually, simple file name patterns are used to take a guess about the type of
	  a file.
	</para>
        <para>
	  The well-known UNIX <command>file</command> command uses a smarter approach: it
	  uses a multi-level approach that examines files, with each level providing less
	  reliable information in case a previous level failed. Roughly, files are scanned
	  on the OS level (examining the result of <function>stat()</function> results) and
	  searched for typical <emphasis>magic</emphasis> bytestrings in order to reliably
	  determine the file's type. See the manpage for more details.
        </para>
        <para>
	  &efsd; uses a similar approach that extends the concept of MIME types from
	  two-level descriptions (such as <emphasis>text/html</emphasis>) to descriptions
          of arbitrary depth. It is then up to the client application to make as much
	  use of the calculated file type as necessary. As an example, a typical reply
	  received when requesting the file type of an MP3 file would be
	  <emphasis>audio/mp3/128-kbit-s/44-1-khz/jstereo</emphasis>.
        </para>
        <para>
	  First &efsd; checks whether the file to examine is an ordinary file. If not,
	  it examines the result of <function>statfs</function> and <function>stat</function>
	  calls and returns a filetype such as <emphasis>dir/ext2</emphasis> or
	  <emphasis>dir/reiserfs</emphasis>. If it is a common readable file, magic
	  tests are performed. If those tests also fail, &efsd; falls back to ordinary
	  filename extension matching. Should those also fail, the default fallback type
          is <emphasis>document/unknown</emphasis>.
	</para>
        <para>
          To request a filetype, use <link linkend="API-efsd-get-filetype"><function>
          efsd_get_filetype()</function></link>. The code pattern is as follows:
	  <programlisting>  
EfsdConnection *ec;
EfsdCmdId id;
EfsdEvent ee;

if ( (ec = efsd_open()) == NULL)
  {
     /* Oops. Couldn't establish connection.
      * Is Efsd really running ?
      */
  }

/* Request the filetype: */

if ( (id = efsd_get_filetype(ec, "/foo/bar")) < 0)
  {
     /* Could not send command. Continue accordingly. */
  }

/* In the event loop, examine the result: */

while (efsd_wait_event(ec, &amp;ee) >= 0)
  {
     /* Handle the event */

     switch (ee.type)
      {
        /* ... */
        case EFSD_EVENT_REPLY:

          switch (ee.efsd_reply_event.command.type)
	   {
	     /* ... */

             case EFSD_CMD_GETFILETYPE:
               if (ee.efsd_reply_event.status == SUCCESS)
	         {
	           printf("Filetype of file %s is %s\n",
                          efsd_reply_filename(&amp;ee),
                          (char*)ee.efsd_reply_event.data);
	         }
	       break;

             /* ... */
           }
	}
  
     /* Cleanup memory allocated for this event */
  
     efsd_event_cleanup(&amp;ee);
  }
	  </programlisting>

	  <caution>
	    <title>Calculating file types is expensive.</title>
            <para>
	      &efsd; potentially has to read many locations in a file and check for magic
	      patterns, which is slow. File type results are cached to improve response times,
	      but you should be aware of the fact that it takes a while when you request
	      file types for every file in a large directory.
            </para>
	  </caution>
        </para>
      </section>

      <section>
        <title>Other File Commands</title>
	  <para>
	  There's a number of other commands that have not been covered yet:

	  <itemizedlist mark="opencircle">
	    <listitem>
	      <para>
               <link linkend="API-efsd-symlink"><function>efsd_symlink()</function></link>
		creates a symbolic link between files. 
              </para>
	    </listitem>
	    <listitem>
	      <para>
               <link linkend="API-efsd-makedir"><function>efsd_makedir()</function></link>
		creates directories. It also allows recursive creation of directory
		branches, like <command>mkdir -p</command> does.
              </para>
	    </listitem>
	    <listitem>
	      <para>
               <link linkend="API-efsd-chmod"><function>efsd_chmod()</function></link>
	       changes permissions on a file, as far as permitted.
              </para>
	    </listitem>
	    <listitem>
	      <para>
               <link linkend="API-efsd-stat"><function>efsd_stat()</function></link> and
               <link linkend="API-efsd-lstat"><function>efsd_lstat()</function></link>
               are the equivalents of the <function>stat()</function> and
	       <function>lstat()</function> system calls.
              </para>
	    </listitem>
	    <listitem>
	      <para>
               <link linkend="API-efsd-readlink"><function>efsd_readlink()</function></link>
	       returns the target of a link in the filesystem.
              </para>
	    </listitem>
	  </itemizedlist>

	  </para>
      </section>

      <section id="options">
	<title id="options.title">Passing Command Options</title>
	<para>
	  Many of the most commonly used commands at the command line use
	  options, think of <command>ls -la</command>, <command>mkdir -p</command>
	  etc. &lefsd; provides a flexible way of combining options for the same purpose.
          Also, the ability to pass options can be a great performance
          improvement: consider the case where monitoring a large directory is requested.
          Chances are that an application will need to initialize data structures
          according to the various <constant>EFSD_FILE_EXISTS</constant> events, and
          that the application will send further commands to &efsd; based on those events.
          By requesting those actions to be taken by passing a single option to the original
          file monitoring request, the communication overhead can be drastically reduced,
          because the request is sent only once, instead of once <emphasis>per
          received <constant>EFSD_FILE_EXISTS</constant> event</emphasis>.
	</para>
	<para>
	  There are two conceivable situations when you encounter the need
	  for options:

	  <itemizedlist mark="opencircle">
	    <listitem>
	      <para>Static combinations of options, known at compile time.</para>
	    </listitem>
	    <listitem>
	      <para>Dynamic combinations of options, unknown at compile time.</para>
	    </listitem>
	  </itemizedlist>
	  
	  Consequently, &lefsd; provides two means for plugging options together. All
          options are constructed using the <function>efsd_op_XXX()</function> calls. For
	  the static case, there's the <link linkend="API-efsd-ops"><function>efsd_ops()
	  </function></link> function, which is variadic. You pass it the number of options
          you are using, and then call the needed option constructors. An example:

	  <programlisting>  
EfsdConnection *ec;
EfsdCmdId id;
EfsdOptions *ops;

/* Connection setup, etc. */

/* Assemble an EfsdOptions structure, containing 2 options:
 * one to list all files (as in ls -a), and one to request
 * alphabetical sorting of the listed files.
 */

ops = efsd_ops(2, efsd_op_list_all(), efsd_op_sort());

/* Now simply pass ops along with the command: */

if ( (id = efsd_listdir(ec, "foo/bar", ops)) < 0)
  {
     /* Could not send command. Continue accordingly. */
  }
	  </programlisting>

	  <caution>
	    <title>You do not need to <function>free()</function> the options.</title>
            <para>
              The <classname>EfsdOptions</classname> are already deallocated by the time
              the &efsd; command returns.
            </para>
	  </caution>

	  The other case is when you need to assemble options dynamically, at runtime
	  <footnote><para><link linkend="efsdshell">&efsdsh;</link> is an example of an application
          where this happens.</para></footnote>. Just create an <classname>EfsdOptions</classname>
          structure using <function>efsd_ops_create()</function>, and then add options created via
          <function>efsd_op_XXX()</function> using <function>efsd_ops_add()</function>.

	  <programlisting>  
EfsdConnection *ec;
EfsdCmdId id;
EfsdOptions *ops;
int show_all, get_stat, get_type, sort;

/* Connection setup, etc. */

/* Determine which options are needed (I assume here
 * that there's at least one), and set the corresponding
 * flags (show_all, get_stat etc).
*/

ops = efsd_ops_create();

if (show_all) efsd_ops_add(ops, efsd_op_list_all());
if (get_stat) efsd_ops_add(ops, efsd_op_get_stat());
if (get_type) efsd_ops_add(ops, efsd_op_get_filetype());
if (sort)     efsd_ops_add(ops, efsd_op_sort());

if ( (id = efsd_start_monitor_dir(ec, "/some/dir", ops)) < 0)
  {
     /* Could not send command. Continue accordingly. */
  }
	  </programlisting>
        <note>
	  <title>If you don't want to give any options, just pass NULL as <classname>EfsdOptions</classname>.</title>
	  <para></para>
	</note>
	
	</para>
	<para>
        When using options on a file/dir monitoring request (through <link linkend="API-efsd-start-monitor">
        <function>efsd_start_monitor()</function></link>), you are guaranteed to receive
        the <constant>EFSD_FILE_EXISTS</constant> events before any results of options applied
	to the files that are covered by the monitor. You can <emphasis>not</emphasis>, however,
        rely on receiving the <constant>EFSD_FILE_EXISTS</constant> events and all the results
	generated through the options before receiving the <constant>EFSD_FILE_EXISTS</constant>
        event for the next file, or on any sequence in which those results arrive. The reason
        is that the actions requested by the options take varying amounts of time and
        &efsd; processes those actions in parallel.
	</para>
      </section>

    </section>

    <section>
      <title>&lefsd; API Documentation</title>
<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-open">efsd_open</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_open</refname>
 <refpurpose>
   Creates and returns an efsd connection. 
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>EfsdConnection * <function>efsd_open </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   </para><para>

   Returns pointer to a newly allocated and initialized
   Efsd connection structure. You need this structure for all
   other calls in order to identify the connection to
   libefsd.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-close">efsd_close</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_close</refname>
 <refpurpose>
      Closes a connection to Efsd.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>int <function>efsd_close </function></funcdef>
   <paramdef>EfsdConnection * <parameter>ec</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ec</parameter></term>
   <listitem>
    <para>
      The Efsd connection
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Use this to close an efsd connection.
   Frees the allocated EfsdConnection structure.
   Returns value &lt; 0 if the the final
   command could not be sent to Efsd.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-get-connection-fd">efsd_get_connection_fd</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_get_connection_fd</refname>
 <refpurpose>
      Returns file descriptor of an Efsd connection.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>int <function>efsd_get_connection_fd </function></funcdef>
   <paramdef>EfsdConnection * <parameter>ec</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ec</parameter></term>
   <listitem>
    <para>
      The Efsd connection
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   If you need to know the file descriptor of the connection
   (such as when <function>select</function>ing it etc), use this accessor function. 
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-events-pending">efsd_events_pending</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_events_pending</refname>
 <refpurpose>
      predicate that tells whether more events have arrived.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>int <function>efsd_events_pending </function></funcdef>
   <paramdef>EfsdConnection * <parameter>ec</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ec</parameter></term>
   <listitem>
    <para>
      The Efsd connection
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   When there are Efsd events waiting to be read, returns value
   greater than zero, zero when there are none, and a value smaller
   than zero when there was an error.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-next-event">efsd_next_event</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_next_event</refname>
 <refpurpose>
      reads and returns next Efsd event, if possible.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>int <function>efsd_next_event </function></funcdef>
   <paramdef>EfsdConnection * <parameter>ec</parameter></paramdef>
   <paramdef>EfsdEvent * <parameter>ev</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ec</parameter></term>
   <listitem>
    <para>
      The Efsd connection
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ev</parameter></term>
   <listitem>
    <para>
      Pointer to an allocated EfsdEvent.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   If available, reads an event that the Efsd daemon sent. It does
   not block. You want to use this if you <function>select</function> Efsd's file
   descriptor. Returns -1 when called on closed connection or no
   data was available, &gt;= 0 otherwise.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-wait-event">efsd_wait_event</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_wait_event</refname>
 <refpurpose>
      blocking wait for next Efsd event.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>int <function>efsd_wait_event </function></funcdef>
   <paramdef>EfsdConnection * <parameter>ec</parameter></paramdef>
   <paramdef>EfsdEvent * <parameter>ev</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ec</parameter></term>
   <listitem>
    <para>
      The Efsd connection
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ev</parameter></term>
   <listitem>
    <para>
      Pointer to an allocated EfsdEvent.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Blocks until an efsd event arrives, then returns it by filling
   in the <parameter>ev</parameter> structure. Returns -1 when there was an error,
   &gt;= 0 otherwise.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-event-cleanup">efsd_event_cleanup</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_event_cleanup</refname>
 <refpurpose>
      cleans up internals of an Efsd event.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>void <function>efsd_event_cleanup </function></funcdef>
   <paramdef>EfsdEvent * <parameter>ev</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ev</parameter></term>
   <listitem>
    <para>
      Pointer to an allocated EfsdEvent.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Events may contain allocated data, which gets cleaned up here.
   Call this one before any other calls to efsd_next_event
   on the same EfsdEvent struct.
   NOTE -- this does not free the EfsdEvent itself -- only
   data that was read into it. If you want to entirely get rid of
   a dynamically allocated EfsdEvent, call <function>efsd_cleanup_event</function>
   first and then simply <function>free</function> the pointer.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-commands-pending">efsd_commands_pending</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_commands_pending</refname>
 <refpurpose>
      whether there are commands still waiting to be sent to Efsd.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>int <function>efsd_commands_pending </function></funcdef>
   <paramdef>EfsdConnection * <parameter>ec</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ec</parameter></term>
   <listitem>
    <para>
      The Efsd connection
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Use this function to find out whether commands are currently queued
   on the client side. Returns value &gt; 0 when commands are queued, 0 when
   the queue is empty, value &lt; 0 when an error occured.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-flush">efsd_flush</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_flush</refname>
 <refpurpose>
      tries to flush the queue of unsent commands.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>int <function>efsd_flush </function></funcdef>
   <paramdef>EfsdConnection * <parameter>ec</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ec</parameter></term>
   <listitem>
    <para>
      The Efsd connection
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   When clients send bursts of commands to the server, it can happen that
   Efsd cannot immediately accept a command. In that case, commands are
   queued on the client side. This queue can be flushed using this command.
   This function tries to send as many commands as possible, and then 
   returns. It does not block. Returns value &gt; 0 when the queue could be
   flushed, 0 otherwise, &lt; 0 when there was an error.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-symlink">efsd_symlink</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_symlink</refname>
 <refpurpose>
      creates a symbolic link between files.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>EfsdCmdId <function>efsd_symlink </function></funcdef>
   <paramdef>EfsdConnection * <parameter>ec</parameter></paramdef>
   <paramdef>char * <parameter>from_file</parameter></paramdef>
   <paramdef>char * <parameter>to_file</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ec</parameter></term>
   <listitem>
    <para>
      The Efsd connection
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>from_file</parameter></term>
   <listitem>
    <para>
      Existing source file of the link
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>to_file</parameter></term>
   <listitem>
    <para>
      Link destination
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Returns command id when successful, a value smaller than zero
   if he command couldn't be sent.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-listdir">efsd_listdir</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_listdir</refname>
 <refpurpose>
      lists the contents of a directory (or also a single file).
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>EfsdCmdId <function>efsd_listdir </function></funcdef>
   <paramdef>EfsdConnection * <parameter>ec</parameter></paramdef>
   <paramdef>char * <parameter>dirname</parameter></paramdef>
   <paramdef>EfsdOptions * <parameter>ops</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ec</parameter></term>
   <listitem>
    <para>
      The Efsd connection
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dirname</parameter></term>
   <listitem>
    <para>
      Directory path. If not an absolute path (starting with '/'), it
     is interpreted as being relative to the current working directory.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ops</parameter></term>
   <listitem>
    <para>
      Efsd options structure.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   When issuing this command, your client will receive <constant>EFSD_FILE_EXISTS</constant>
   events for all files in the directory, or, if for some reason the
   command is issued on a file, for the file only. The directory is
   not monitored afterwards, you just get the contents delivered once.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-copy">efsd_copy</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_copy</refname>
 <refpurpose>
      copies a number of files to a target file.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>EfsdCmdId <function>efsd_copy </function></funcdef>
   <paramdef>EfsdConnection * <parameter>ec</parameter></paramdef>
   <paramdef>int <parameter>num_files</parameter></paramdef>
   <paramdef>char ** <parameter>files</parameter></paramdef>
   <paramdef>EfsdOptions * <parameter>ops</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ec</parameter></term>
   <listitem>
    <para>
      The Efsd connection
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num_files</parameter></term>
   <listitem>
    <para>
      The number of files passed
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>files</parameter></term>
   <listitem>
    <para>
      Array of strings, must contain at least <parameter>num_files</parameter> items.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ops</parameter></term>
   <listitem>
    <para>
      EfsdOptions pointer, created using either <function>efsd_ops</function> or
     <function>efsd_ops_create</function> and <function>efsd_ops_add</function>.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Copies files. If <parameter>num_files</parameter> &gt; 2, the last file must be a directory.
   Currently, meaningful options are <function>efsd_op_force</function> and <function>efsd_op_recursive</function>.
   The force option causes existing files at the target to be removed.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-move">efsd_move</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_move</refname>
 <refpurpose>
      moves a number of files to a target file.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>EfsdCmdId <function>efsd_move </function></funcdef>
   <paramdef>EfsdConnection * <parameter>ec</parameter></paramdef>
   <paramdef>int <parameter>num_files</parameter></paramdef>
   <paramdef>char ** <parameter>files</parameter></paramdef>
   <paramdef>EfsdOptions * <parameter>ops</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ec</parameter></term>
   <listitem>
    <para>
      The Efsd connection
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num_files</parameter></term>
   <listitem>
    <para>
      The number of files passed
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>files</parameter></term>
   <listitem>
    <para>
      Array of strings, must contain at least <parameter>num_files</parameter> items.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ops</parameter></term>
   <listitem>
    <para>
      EfsdOptions pointer, created using either <function>efsd_ops</function> or
     <function>efsd_ops_create</function> and <function>efsd_ops_add</function>.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Moves files. If <parameter>num_files</parameter> &gt; 2, the last file must be a directory.
   Currently, the only meaningful option is <function>efsd_op_force</function>,
   which causes existing files at the target to be removed.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-remove">efsd_remove</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_remove</refname>
 <refpurpose>
      removes a number of files.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>EfsdCmdId <function>efsd_remove </function></funcdef>
   <paramdef>EfsdConnection * <parameter>ec</parameter></paramdef>
   <paramdef>int <parameter>num_files</parameter></paramdef>
   <paramdef>char ** <parameter>files</parameter></paramdef>
   <paramdef>EfsdOptions * <parameter>ops</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ec</parameter></term>
   <listitem>
    <para>
      The Efsd connection
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>num_files</parameter></term>
   <listitem>
    <para>
      The number of files passed
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>files</parameter></term>
   <listitem>
    <para>
      Array of strings, must contain at least <parameter>num_files</parameter> items.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ops</parameter></term>
   <listitem>
    <para>
      EfsdOptions pointer, created using either <function>efsd_ops</function> or
     <function>efsd_ops_create</function> and <function>efsd_ops_add</function>.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Copies files. If <parameter>num_files</parameter> &gt; 2, the last file must be a directory.
   Currently, meaningful options are <function>efsd_op_force</function> and <function>efsd_op_recursive</function>.
   The force option causes the success status of the command to be
   <quote>success</quote> even when targets don't exist.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-makedir">efsd_makedir</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_makedir</refname>
 <refpurpose>
      creates a directory.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>EfsdCmdId <function>efsd_makedir </function></funcdef>
   <paramdef>EfsdConnection * <parameter>ec</parameter></paramdef>
   <paramdef>char * <parameter>dirname</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ec</parameter></term>
   <listitem>
    <para>
      The Efsd connection
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dirname</parameter></term>
   <listitem>
    <para>
      The directory path.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   <function>efsd_makedir</function> behaves like mkdir -p, i.e. it
   can create directories recursively.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-chmod">efsd_chmod</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_chmod</refname>
 <refpurpose>
      change permissions on a file.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>EfsdCmdId <function>efsd_chmod </function></funcdef>
   <paramdef>EfsdConnection * <parameter>ec</parameter></paramdef>
   <paramdef>char * <parameter>filename</parameter></paramdef>
   <paramdef>mode_t <parameter>mode</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ec</parameter></term>
   <listitem>
    <para>
      The Efsd connection
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>filename</parameter></term>
   <listitem>
    <para>
      The file whose permissions are to be changed
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>mode</parameter></term>
   <listitem>
    <para>
      the new permissions
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Changes the given file to the given mode.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-set-metadata-raw">efsd_set_metadata_raw</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_set_metadata_raw</refname>
 <refpurpose>
      set raw binary metadata on a file.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>EfsdCmdId <function>efsd_set_metadata_raw </function></funcdef>
   <paramdef>EfsdConnection * <parameter>ec</parameter></paramdef>
   <paramdef>char * <parameter>key</parameter></paramdef>
   <paramdef>char * <parameter>filename</parameter></paramdef>
   <paramdef>EfsdDatatype <parameter>datatype</parameter></paramdef>
   <paramdef>int <parameter>datalength</parameter></paramdef>
   <paramdef>void * <parameter>data</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ec</parameter></term>
   <listitem>
    <para>
      The Efsd connection
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
      A character string which unambiguously identifies the data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>filename</parameter></term>
   <listitem>
    <para>
      The file on which to set the metadata.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>datatype</parameter></term>
   <listitem>
    <para>
      The type of the data. One of <constant>EFSD_INT</constant>,
     <constant>EFSD_FLOAT</constant>, <constant>EFSD_STRING</constant> or <constant>EFSD_RAW</constant>.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>datalength</parameter></term>
   <listitem>
    <para>
      The length of the data chunk, in bytes.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data</parameter></term>
   <listitem>
    <para>
      The data itself.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This command sets arbitrary binary data as metadata on a file.
   The data is labeled by the given key, which must therefore be
   unique among all the metadata set for a file.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-set-metadata-int">efsd_set_metadata_int</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_set_metadata_int</refname>
 <refpurpose>
      set integer metadata on a file.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>EfsdCmdId <function>efsd_set_metadata_int </function></funcdef>
   <paramdef>EfsdConnection * <parameter>ec</parameter></paramdef>
   <paramdef>char * <parameter>key</parameter></paramdef>
   <paramdef>char * <parameter>filename</parameter></paramdef>
   <paramdef>int <parameter>val</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ec</parameter></term>
   <listitem>
    <para>
      The Efsd connection
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
      A character string which unambiguously identifies the data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>filename</parameter></term>
   <listitem>
    <para>
      The file on which to set the metadata.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>val</parameter></term>
   <listitem>
    <para>
      An integer value.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This command sets an integer value as metadata on a file.
   The data is labeled by the given key, which must therefore be
   unique among all the metadata set for a file.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-set-metadata-float">efsd_set_metadata_float</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_set_metadata_float</refname>
 <refpurpose>
      set floating-point metadata on a file.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>EfsdCmdId <function>efsd_set_metadata_float </function></funcdef>
   <paramdef>EfsdConnection * <parameter>ec</parameter></paramdef>
   <paramdef>char * <parameter>key</parameter></paramdef>
   <paramdef>char * <parameter>filename</parameter></paramdef>
   <paramdef>float <parameter>val</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ec</parameter></term>
   <listitem>
    <para>
      The Efsd connection
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
      A character string which unambiguously identifies the data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>filename</parameter></term>
   <listitem>
    <para>
      The file on which to set the metadata.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>val</parameter></term>
   <listitem>
    <para>
      A floating-point value.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This command sets a floating point value as metadata on a file.
   The data is labeled by the given key, which must therefore be
   unique among all the metadata set for a file.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-set-metadata-str">efsd_set_metadata_str</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_set_metadata_str</refname>
 <refpurpose>
      set character string metadata on a file.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>EfsdCmdId <function>efsd_set_metadata_str </function></funcdef>
   <paramdef>EfsdConnection * <parameter>ec</parameter></paramdef>
   <paramdef>char * <parameter>key</parameter></paramdef>
   <paramdef>char * <parameter>filename</parameter></paramdef>
   <paramdef>char * <parameter>val</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ec</parameter></term>
   <listitem>
    <para>
      The Efsd connection
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
      A character string which unambiguously identifies the data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>filename</parameter></term>
   <listitem>
    <para>
      The file on which to set the metadata.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>val</parameter></term>
   <listitem>
    <para>
      A C string.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This command sets C string data as metadata on a file.
   The data is labeled by the given key, which must therefore be
   unique among all the metadata set for a file.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-get-metadata">efsd_get_metadata</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_get_metadata</refname>
 <refpurpose>
      retrieve file metadata.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>EfsdCmdId <function>efsd_get_metadata </function></funcdef>
   <paramdef>EfsdConnection * <parameter>ec</parameter></paramdef>
   <paramdef>char * <parameter>key</parameter></paramdef>
   <paramdef>char * <parameter>filename</parameter></paramdef>
   <paramdef>EfsdDatatype <parameter>datatype</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ec</parameter></term>
   <listitem>
    <para>
      The Efsd connection
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
      A character string which unambiguously identifies the data
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>filename</parameter></term>
   <listitem>
    <para>
      The file on which to set the metadata.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>datatype</parameter></term>
   <listitem>
    <para>
      The datatype of the data to retrieve. One of <constant>EFSD_INT</constant>,
     <constant>EFSD_FLOAT</constant>, <constant>EFSD_STRING</constant> or <constant>EFSD_RAW</constant>.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This command causes the metadata indexed by the given key to be
   transmitted to the client.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-metadata-get-type">efsd_metadata_get_type</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_metadata_get_type</refname>
 <refpurpose>
      returns the data type of retrieved metadata.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>EfsdDatatype <function>efsd_metadata_get_type </function></funcdef>
   <paramdef>EfsdEvent * <parameter>ee</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ee</parameter></term>
   <listitem>
    <para>
      The received EfsdEvent.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Convenience function that returns the data type of the metadata
   received. If the event does not contain any metadata, the return
   value is 0 (which is not a valid data type), &gt; 0 otherwise.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-metadata-get-int">efsd_metadata_get_int</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_metadata_get_int</refname>
 <refpurpose>
      returns integer value from retrieved metadata.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>int <function>efsd_metadata_get_int </function></funcdef>
   <paramdef>EfsdEvent * <parameter>ee</parameter></paramdef>
   <paramdef>int * <parameter>val</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ee</parameter></term>
   <listitem>
    <para>
      The received EfsdEvent.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>val</parameter></term>
   <listitem>
    <para>
      Pointer to an integer that is overwritten with the received value.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Convenience function that returns integer metadata from a reply
   event in <parameter>val</parameter>. If the event does not contain integer metadata,
   the function returns 0, a value &gt; 0 otherwise.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-metadata-get-float">efsd_metadata_get_float</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_metadata_get_float</refname>
 <refpurpose>
      returns floating-point value from retrieved metadata.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>int <function>efsd_metadata_get_float </function></funcdef>
   <paramdef>EfsdEvent * <parameter>ee</parameter></paramdef>
   <paramdef>float * <parameter>val</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ee</parameter></term>
   <listitem>
    <para>
      The received EfsdEvent.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>val</parameter></term>
   <listitem>
    <para>
      Pointer to a float that is overwritten with the received value.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Convenience function that returns floating-point metadata from a reply
   event in <parameter>val</parameter>. If the event does not contain floating-point metadata,
   the function returns 0, a value &gt; 0 otherwise.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-metadata-get-str">efsd_metadata_get_str</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_metadata_get_str</refname>
 <refpurpose>
      returns a character string from retrieved metadata.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>char          * <function>efsd_metadata_get_str </function></funcdef>
   <paramdef>EfsdEvent * <parameter>ee</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ee</parameter></term>
   <listitem>
    <para>
      The received EfsdEvent.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Convenience function that returns character string metadata from a reply
   event in <parameter>val</parameter>. If the event does not contain string metadata,
   the function returns <constant>NULL</constant>, the string otherwise. You do not need to <function>free</function>
   the string, it gets deallocated when the event gets cleaned up. So when you
   want to keep it around, you need to <function>strdup</function> it.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-metadata-get-raw">efsd_metadata_get_raw</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_metadata_get_raw</refname>
 <refpurpose>
       returns the raw data from retrieved metadata.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>void          * <function>efsd_metadata_get_raw </function></funcdef>
   <paramdef>EfsdEvent * <parameter>ee</parameter></paramdef>
   <paramdef>int * <parameter>data_len</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ee</parameter></term>
   <listitem>
    <para>
      The received EfsdEvent.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>data_len</parameter></term>
   <listitem>
    <para>
      Pointer to an integer that returns the length of the data chunk.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Convenience function that returns raw metadata from a reply
   event. If the event does not contain string metadata, the function returns
   NULL, the data otherwise. You do not need to <function>free</function> the data, it gets
   deallocated when the event gets cleaned up. So when you
   want to keep it around, you need to <function>memdup</function> it. If for some reason you're
   not interested in the data length, you can pass <parameter>data_len</parameter> as <constant>NULL</constant>.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-metadata-get-key">efsd_metadata_get_key</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_metadata_get_key</refname>
 <refpurpose>
      returns key that identifies retrieved metadata.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>char          * <function>efsd_metadata_get_key </function></funcdef>
   <paramdef>EfsdEvent * <parameter>ee</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ee</parameter></term>
   <listitem>
    <para>
      The received EfsdEvent.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Convenience function that returns the key that was used to look up
   the metadata returned to the client. If the event does not contain
   any metadata, the return value is <constant>NULL</constant>. You do not need to <function>free</function>
   the string, it gets deallocated when the event gets cleaned up. So when you
   want to keep it around, you need to <function>strdup</function> it.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-metadata-get-file">efsd_metadata_get_file</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_metadata_get_file</refname>
 <refpurpose>
      returns the full filename for which metadata
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>char          * <function>efsd_metadata_get_file </function></funcdef>
   <paramdef>EfsdEvent * <parameter>ee</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ee</parameter></term>
   <listitem>
    <para>
      The received EfsdEvent.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Convenience function that returns the filename from a metadata reply
   event. If the event does not contain metadata, the function returns
   <constant>NULL</constant>, the filename otherwise. You do not need to <function>free</function> the string,
   it gets deallocated when the event gets cleaned up. So when you
   want to keep it around, you need to <function>strdup</function> it.
 </para>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Convenience function that returns the filename from a metadata reply
   event. If the event does not contain metadata, the function returns
   <constant>NULL</constant>, the filename otherwise. You do not need to <function>free</function> the string,
   it gets deallocated when the event gets cleaned up. So when you
   want to keep it around, you need to <function>strdup</function> it.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-reply-filename">efsd_reply_filename</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_reply_filename</refname>
 <refpurpose>
      returns filename contained in an event.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>char          * <function>efsd_reply_filename </function></funcdef>
   <paramdef>EfsdEvent * <parameter>ee</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ee</parameter></term>
   <listitem>
    <para>
      The EfsdEvent.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Convenience function to access the filenames in reply or
   filechange events. If the event is a reply event and the
   contained command is an efsd_file_cmd, it returns the first file
   (efsd_file_cmd.files[0]). Returns <constant>NULL</constant> if no file could be
   found.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-reply-id">efsd_reply_id</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_reply_id</refname>
 <refpurpose>
      returns command id contained in an event.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>EfsdCmdId <function>efsd_reply_id </function></funcdef>
   <paramdef>EfsdEvent * <parameter>ee</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ee</parameter></term>
   <listitem>
    <para>
      The EfsdEvent.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Convenience function to access the command ID in reply or
   filechange events. Returns -1 if no ID is contained in the event.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-start-monitor">efsd_start_monitor</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_start_monitor</refname>
 <refpurpose>
      start monitoring a directory for file events.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>EfsdCmdId <function>efsd_start_monitor </function></funcdef>
   <paramdef>EfsdConnection * <parameter>ec</parameter></paramdef>
   <paramdef>char * <parameter>filename</parameter></paramdef>
   <paramdef>EfsdOptions * <parameter>ops</parameter></paramdef>
   <paramdef>int <parameter>dir_mode</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ec</parameter></term>
   <listitem>
    <para>
      The Efsd connection
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>filename</parameter></term>
   <listitem>
    <para>
      The name of the directory that is to be monitored.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>ops</parameter></term>
   <listitem>
    <para>
      Pointer to EfsdOptions.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dir_mode</parameter></term>
   <listitem>
    <para>
      Whether this is a directory monitor or not, either TRUE
     or FALSE.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Use this command when you want to be informed when things happen to
   a directory and all of the files contained in it. You will receive
   a series of <constant>EFSD_FILE_EXISTS</constant> events for all files in the directory.
   You know that no further <constant>EFSD_FILE_EXISTS</constant> events will be received when
   you see <constant>EFDS_FILE_END_EXISTS</constant>.
   </para><para>

   If you pass options, they are applied to every file for which an
   <constant>EFSD_FILE_EXISTS</constant> event is generated. Therefore, meaningful options
   are efsd_op_get_stat, <function>efsd_op_get_lstat</function>, <function>efsd_op_get_metadata</function>,
   <function>efsd_op_get_filetype</function>, <function>efsd_op_sort</function> and <function>efsd_op_list_all</function>.
   You can rely on the fact that the <constant>EFSD_FILE_EXISTS</constant> events will be
   received before any results of options applied to the files. You
   can not rely on receiving the <constant>EFSD_FILE_EXISTS</constant> events and all the
   results generated through the options, before receiving the
   <constant>EFSD_FILE_EXISTS</constant> event for the next file. 
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-stop-monitor">efsd_stop_monitor</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_stop_monitor</refname>
 <refpurpose>
      stops monitoring a file or directory.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>EfsdCmdId <function>efsd_stop_monitor </function></funcdef>
   <paramdef>EfsdConnection * <parameter>ec</parameter></paramdef>
   <paramdef>char * <parameter>filename</parameter></paramdef>
   <paramdef>int <parameter>dir_mode</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ec</parameter></term>
   <listitem>
    <para>
      The Efsd connection.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>filename</parameter></term>
   <listitem>
    <para>
      The file that is to be no longer monitored.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>dir_mode</parameter></term>
   <listitem>
    <para>
      Whether this is a directory monitor or not, either TRUE
     or FALSE.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This command stops reporting of filechange events to <parameter>filename</parameter> (and,
   if <parameter>filename</parameter> is a directory, any files in the directory).
   Clients receive a <constant>EFSD_FILE_ACKNOWLEDGE</constant> event as a reply, which
   guarantees that no further file change events for this file will
   be sent to the client that requested the monitoring to be stopped.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-stat">efsd_stat</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_stat</refname>
 <refpurpose>
      returns the result of <function>stat</function> on a file.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>EfsdCmdId <function>efsd_stat </function></funcdef>
   <paramdef>EfsdConnection * <parameter>ec</parameter></paramdef>
   <paramdef>char * <parameter>filename</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ec</parameter></term>
   <listitem>
    <para>
      The Efsd connection.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>filename</parameter></term>
   <listitem>
    <para>
      The name of the file that is to be <function>stat</function>ed.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-lstat">efsd_lstat</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_lstat</refname>
 <refpurpose>
      returns the result of <function>lstat</function> on a file.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>EfsdCmdId <function>efsd_lstat </function></funcdef>
   <paramdef>EfsdConnection * <parameter>ec</parameter></paramdef>
   <paramdef>char * <parameter>filename</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ec</parameter></term>
   <listitem>
    <para>
      The Efsd connection.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>filename</parameter></term>
   <listitem>
    <para>
      The name of the file that is to be <function>lstat</function>ed.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-readlink">efsd_readlink</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_readlink</refname>
 <refpurpose>
      returns the file a symlink points to.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>EfsdCmdId <function>efsd_readlink </function></funcdef>
   <paramdef>EfsdConnection * <parameter>ec</parameter></paramdef>
   <paramdef>char * <parameter>filename</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ec</parameter></term>
   <listitem>
    <para>
      The Efsd connection.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>filename</parameter></term>
   <listitem>
    <para>
      The name of the symbolic link whose target is to be read.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-get-filetype">efsd_get_filetype</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_get_filetype</refname>
 <refpurpose>
      returns the filetype of a file.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>EfsdCmdId <function>efsd_get_filetype </function></funcdef>
   <paramdef>EfsdConnection * <parameter>ec</parameter></paramdef>
   <paramdef>char * <parameter>filename</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ec</parameter></term>
   <listitem>
    <para>
      The Efsd connection.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>filename</parameter></term>
   <listitem>
    <para>
      The name of the file whose type is to be computed.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This function returns the filetype of a file, using a fairly
   sophisticated algorithm not unlike that of the file(1) command.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-ops">efsd_ops</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_ops</refname>
 <refpurpose>
      statically assemble an EfsdOptions structure.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>EfsdOptions  * <function>efsd_ops </function></funcdef>
   <paramdef>int <parameter>num_options</parameter></paramdef>
   <paramdef>... <parameter>...</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>num_options</parameter></term>
   <listitem>
    <para>
      The number of options that you create in the call.
     You have to make this many option constructor calls (<function>efsd_op_XXX</function>)
     afterwards.
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>...</parameter></term>
   <listitem>
    <para>
     variable arguments
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   This is the solution for passing options to commands when you
   know at compile time what options you want to pass. Returns
   a pointer to a ready-made EfsdOptions structure. You do NOT need
   to free it after you've launched the command, it is
   freed by the time the command routine returns.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-ops-create">efsd_ops_create</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_ops_create</refname>
 <refpurpose>
      create an empty EfsdOptions structure.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>EfsdOptions  * <function>efsd_ops_create </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   </para><para>

   Use this function when you need to pass a number of options and do not
   know their number at compile time. Pass the returned EfsdOptions structure
   to subsequent <function>efsd_ops_add</function> calls, then pass it to the actual command.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-ops-add">efsd_ops_add</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_ops_add</refname>
 <refpurpose>
      adds an option to an EfsdOptions structure.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>void <function>efsd_ops_add </function></funcdef>
   <paramdef>EfsdOptions * <parameter>ops</parameter></paramdef>
   <paramdef>EfsdOption * <parameter>op</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>ops</parameter></term>
   <listitem>
    <para>
      EfsdOptions structure, created via <function>efsd_ops_create</function>
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>op</parameter></term>
   <listitem>
    <para>
      Option to add, created via one of the <function>efsd_op_XXX</function> calls
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Add options to an EfsdOptions structure using this function.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-op-get-stat">efsd_op_get_stat</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_op_get_stat</refname>
 <refpurpose>
      requests stat events
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>EfsdOption    * <function>efsd_op_get_stat </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   </para><para>

   Creates an option that causes <function>stat</function> results to be sent to the
   client for all files seen in <constant>EFSD_FILE_EXIST</constant> events.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-op-get-lstat">efsd_op_get_lstat</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_op_get_lstat</refname>
 <refpurpose>
      requests lstat events
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>EfsdOption    * <function>efsd_op_get_lstat </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   </para><para>

   Creates an option that causes <function>lstat</function> results to be sent to the
   client for all files seen in <constant>EFSD_FILE_EXIST</constant> events.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-op-get-metadata">efsd_op_get_metadata</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_op_get_metadata</refname>
 <refpurpose>
      request metadata information
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>EfsdOption    * <function>efsd_op_get_metadata </function></funcdef>
   <paramdef>char * <parameter>key</parameter></paramdef>
   <paramdef>EfsdDatatype <parameter>type</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>key</parameter></term>
   <listitem>
    <para>
      character string that identifies the metadata
    </para>
   </listitem>
  </varlistentry>
  <varlistentry>
   <term><parameter>type</parameter></term>
   <listitem>
    <para>
      datatype of the metadata, one of <constant>EFSD_INT</constant>,
     <constant>EFSD_FLOAT</constant>, <constant>EFSD_STRING</constant> or <constant>EFSD_RAW</constant>.
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   Creates an option that causes metadata of certain key and type
   to be sent to the client, for all files reported in <constant>EFSD_FILE_EXIST</constant>
   events.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-op-get-filetype">efsd_op_get_filetype</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_op_get_filetype</refname>
 <refpurpose>
      request filetype information
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>EfsdOption    * <function>efsd_op_get_filetype </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   </para><para>

   Creates an option that causes file type information to be sent
   to the client, for all files reported in <constant>EFSD_FILE_EXIST</constant>
   events.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-op-force">efsd_op_force</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_op_force</refname>
 <refpurpose>
      request <quote>-f</quote> behaviour
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>EfsdOption    * <function>efsd_op_force </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   </para><para>

   Creates an option that causes commands like <function>efsd_move</function>, <function>efsd_copy</function>
   and <function>efsd_remove</function> to operate like the command-line versions, when
   passed the <quote>-f</quote> option.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-op-recursive">efsd_op_recursive</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_op_recursive</refname>
 <refpurpose>
      request recursive behaviour
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>EfsdOption    * <function>efsd_op_recursive </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   </para><para>

   Creates an option that causes commands like <function>efsd_copy</function>
   and <function>efsd_remove</function> to operate like the command-line versions, when
   passed the <quote>-r</quote> option.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-op-sort">efsd_op_sort</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_op_sort</refname>
 <refpurpose>
      report <constant>EFSD_FILE_EXISTS</constant> events alphabetically.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>EfsdOption    * <function>efsd_op_sort </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   </para><para>

   This option constructor returns an EfsdOption that causes <constant>EFSD_FILE_EXISTS</constant> events to
   be reported in alphabetical order.
 </para>
</refsect1>
</refentry>

<refentry>
<refmeta>
<refentrytitle><phrase id="API-efsd-op-list-all">efsd_op_list_all</phrase></refentrytitle>
</refmeta>
<refnamediv>
 <refname>efsd_op_list_all</refname>
 <refpurpose>
      include hidden files in <constant>EFSD_FILE_EXISTS</constant> events.
 </refpurpose>
</refnamediv>
<refsynopsisdiv>
 <title>Synopsis</title>
  <funcsynopsis>
   <funcdef>EfsdOption    * <function>efsd_op_list_all </function></funcdef>
   <paramdef> <parameter>void</parameter></paramdef>
  </funcsynopsis>
</refsynopsisdiv>
<refsect1>
 <title>Arguments</title>
 <variablelist>
  <varlistentry>
   <term><parameter>void</parameter></term>
   <listitem>
    <para>
    </para>
   </listitem>
  </varlistentry>
 </variablelist>
</refsect1>
<refsect1>
 <title>Description</title>
 <para>
   </para><para>

   This option constructor returns an EfsdOption that causes Efsd to send
   <constant>EFSD_FILE_EXISTS</constant> also for hidden files (starting with a '.').
 </para>
</refsect1>
</refentry>

    </section>
  </chapter>

  <chapter id="efsd">
    <title id="efsd.title">&efsd; - The Server Side</title>
    <section id="using-efsd-server">
      <title id="using-efsd-server.title">Using &efsd;</title>
      <para>
	To launch the server, simply start the <command>efsd</command> binary. You could
	  do this in a number of ways, such as from you X Window startup scripts
	  (such as <filename>.xsession</filename>) or, if you have appropriate permissions,
	  from the startup scripts in <filename>/etc/init.d</filename> directory
	  <footnote><para>The actual name of the directory depends on your operating system.</para>
	  </footnote>.
      </para>
      <para>
	The &efsd; server understands a small number of command-line options to influence
	its verbosity:

	<table frame="all">
	  <title>&efsd; Command-line Options</title>
	  <tgroup cols="2">
	    <colspec colname="option" colwidth="*">
	    <colspec colname="effect" colwidth="7*">
	    <thead>
	      <row>
		<entry>Option</entry>
		<entry>Effect</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry><command>-h, --help</command></entry>
		<entry>Displays help message, then exits.</entry>
	      </row>
	      <row>
		<entry><command>-f, --foreground</command></entry>
		<entry>Keeps the server from forking into the background, as it normally
		  does.</entry>
	      </row>
	      <row>
		<entry><command>-c, --careful</command></entry>
		<entry>If the I/O socket file to communicate with clients exists
		  already, do not start. Normally the socket file gets overwritten
		  with a new one when &efsd; starts.</entry>
	      </row>
	      <row>
		<entry><command>-d, --debug</command></entry>
		<entry>Displays debugging messages along with PID/thread ID. This
		  is only available when &efsd; was compiled accordingly.</entry>
	      </row>
	      <row>
		<entry><command>-t, --tree</command></entry>
		<entry>Displays a call tree for debugging purposes. This creates a
		  <emphasis>LOT</emphasis> of output (quickly filling tens of megabytes),
		  so use this option with care when redirecting the output into files etc.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
      </para>
    </section>
    <section>
      <title>Tour of the Source Files</title>
      <para>
         The purpose of this section is to give a quick overview of what's contained
         in the source files (contained in the <function>/efsd</function> subdirectory).
         The following naming scheme is used throughout the code:

	<caution>
	  <title>When writing new functions, make sure to use the <function>D_ENTER</function>
	    and <function>D_RETURN</function> macros!</title>
	  <para>
	    Those macros make sure that the call tree is displayed correctly. Only in
	    case of really minor functions or heavily called nested ones should you consider
	    leaving those macros out. They greatly help in case of debugging when you need
	    to pinpoint where things are going wrong.
	  </para>
	</caution>

      </para>
      <para>
	Also, please stick to the following conventions when adding new code:

	<itemizedlist mark="opencircle">
	  <listitem>
	    <para>Every non-static function has the prefix <function>efsd_</function>.</para>
	  </listitem>
	  <listitem>
	    <para>All functions declared in the same header file have the same sub-prefix
	      (e.g., every function declared in <function>efsd_monitor.h</function> begins
	      with <function>efsd_monitor_</function>). This should make it easy enough
	      to quickly find things even on a first read.
	    </para>
	  </listitem>
	  <listitem>
	    <para>Static functions use the same sub-prefix, but don't have the
	      <function>efsd_</function> prefix.
	    </para>
	  </listitem>
	</itemizedlist>

	<table frame="all">
	  <title>Source File Contents</title>
	  <tgroup cols="2">
	    <colspec colname="filenames" colwidth="*">
	    <colspec colname="descr" colwidth="7*">
	    <thead>
	      <row>
		<entry>File</entry>
		<entry>Contents</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry><filename>efsd.h]</filename></entry>
		<entry>&efsd; data type definitions. This header file gets installed
		  when <command>make install</command> is run.</entry>
	      </row>
	      <row>
		<entry><filename>efsd_commands.[ch]</filename></entry>
		<entry>Toplevel calls for efsd commands. Handles error codes
		  and initiates sending of replies.</entry>
	      </row>
	      <row>
		<entry><filename>efsd_debug.[ch]</filename></entry>
		<entry>Macros for debugging output and call tree tracing,
		  including functions to manage call depths in thread-specific
		  data.</entry>
	      </row>
	      <row>
		<entry><filename>efsd_dynarray.[ch]</filename></entry>
		<entry>A dynamic array of charachter strings that can
		  be sorted, inserted into etc.</entry>
	      </row>
	      <row>
		<entry><filename>efsd_fam_r.[ch]</filename></entry>
		<entry>Reentrant versions of the FAM API, realized by
		  simple mutex locking around the original calls.</entry>
	      </row>
	      <row>
		<entry><filename>efsd_filetype.[ch]</filename></entry>
		<entry>Filetype lookup and database management, libxml
		  interface to database file</entry>
	      </row>
	      <row>
		<entry><filename>efsd_fs.[ch]</filename></entry>
		<entry>Traditional file system calls are implemented here,
		  such as <command>cp</command>,<command>rm</command> etc.</entry>
	      </row>
	      <row>
		<entry><filename>efsd_globals.h</filename></entry>
		<entry>Global variables. Other than command line options,
		  basically only the most important file descriptors.</entry>
	      </row>
	      <row>
		<entry><filename>efsd_hash.[ch]</filename></entry>
		<entry>A generic hashtable implementation, using
		  function pointers for the hash functions and cleanup
		  functions, also standard hash functions such as for
		  strings.
		</entry>
	      </row>
	      <row>
		<entry><filename>efsd_io.[ch]</filename></entry>
		<entry>Client-server communication. Handles the details
		  of how to send/receive efsd commands.</entry>
	      </row>
	      <row>
		<entry><filename>efsd_list.[ch]</filename></entry>
		<entry>A generic list implementation, using function
		  pointers for cleanup calls and providing various
		  means to append, prepend, remove or shift entries.</entry>
	      </row>
	      <row>
		<entry><filename>efsd_lock.[ch]</filename></entry>
		<entry>A single-write/multiple-read lock implementation,
		  needed in the multithreaded versions.</entry>
	      </row>
	      <row>
		<entry><filename>efsd_macros.h</filename></entry>
		<entry>Common macro definitions,
		  <function>malloc</function>/<function>free</function> wrappers,
		  threadedness/nonthreadedness wrappers.</entry>
	      </row>
	      <row>
		<entry><filename>efsd_main.[ch]</filename></entry>
		<entry>Main event loops, FAM event handling, client-server
		  interprocess communication, exit + signal handlers.</entry>
	      </row>
	      <row>
		<entry><filename>efsd_meta.[ch]</filename></entry>
		<entry>Metadata management module.</entry>
	      </row>
	      <row>
		<entry><filename>efsd_misc.[ch]</filename></entry>
		<entry>Assembly of all kinds of little helpers that
		  didn't fit elsewhere.</entry>
	      </row>
	      <row>
		<entry><filename>efsd_monitor.[ch]</filename></entry>
		<entry>File monitoring, for now basically the FAM
		  interface. Implements the entire monitor management,
		  relying on the statcache among other things.</entry>
	      </row>
	      <row>
		<entry><filename>efsd_options.[ch]</filename></entry>
		<entry>&efsd; command options allocation/cleanup.</entry>
	      </row>
	      <row>
		<entry><filename>efsd_queue.[ch]</filename></entry>
		<entry>An &efsd; event queue implementation. This needs
		  to be cleaned up into a generic queue and a specific
		  event queue implementation at some point.</entry>
	      </row>
	      <row>
		<entry><filename>efsd_stack.[ch]</filename></entry>
		<entry>A generic stack implementation, based on the list
		  described above.</entry>
	      </row>
	      <row>
		<entry><filename>efsd_statcache.[ch]</filename></entry>
		<entry>The stat subsystem. Implements both
		  <function>stat</function> and <function>lstat</function>
		  calls, while caching the results relying on file monitoring
		  to speed things up.</entry>
	      </row>
	      <row>
		<entry><filename>efsd_types.[ch]</filename></entry>
		<entry>Allocation/Deallocation for the most commonly
		  used data types.</entry>
	      </row>
	      <row>
		<entry><filename>libefsd.[ch]</filename></entry>
		<entry>&lefsd; implementation and header file, the header
		  gets installed when calling <command>make install</command>.</entry>
	      </row>
	      <row>
		<entry><filename>libefsd_misc.[ch]</filename></entry>
		<entry>Helper functions for &lefsd;.</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
	
      </para>
    </section>

<!--

    <section id="efsd-ipc">
      <title id="efsd-ipc.title">IPC mechanisms</title>
      <para>
      </para>
    </section>
    <section id="efsd-filetypes">
      <title id="efsd-filetypes.title">Filetype Module</title>
      <para>
      </para>
    </section>
    <section id="efsd-commands">
      <title id="efsd-commands.title">File Commands Module</title>
      <para>
      </para>
    </section>
    <section id="efsd-meta">
      <title id="efsd-meta.title">Metadata Module</title>
      <para>
      </para>
    </section>
    <section>
      <title>Stat Cache</title>
      <para>
      </para>
    </section>
    <section>
      <title>File Monitoring Module</title>
      <para>
      </para>
    </section>
    <section>
      <title>Advanced Data Structures</title>
      <para>
      </para>
    </section>
    <section id="multithreading">
      <title id="multithreading.title">Multithreaded Implementation</title>
      <para>
      </para>
    </section>

-->
  </chapter>

  <chapter id="efsdshell">
    <title>&efsdsh; - An Interactive &efsd; Client</title>
    <para>    	     
      The &efsd; distribution comes with a useful tool for testing and playing with &efsd;
      -- that's &efsdsh;, the &efsd; shell <footnote><para>"Shell" is a bit of exaggeration, since &efsdsh;
      provides only a small subset of a real shell's functionality.</para></footnote>. It provides
      a simplified command line prompt, where you can send commands to &efsd; in the usual fashion, i.e.
      a directory copy command is <function>cp -r /some/dir /some/other/dir</function> etc.
      Enter <function>help</function> at the prompt to get an overview of the available commands and
      options.
    </para>
    <para>
      Besides being useful for testing &efsd; commands, &efsdsh; is also great for testing &efsd;'s
      behaviour when handling multiple clients - just launch a bunch of &efsdsh;s and watch how
      file monitoring requests are answered in a few of them etc.
    </para>
    <para>
      Notice that &efsd; must be running when starting &efsdsh;, it does not do that for you.
    </para>
  </chapter>

  <chapter id="filetypesdb">
    <title>&efsd;'s Filetype Database</title>
    <para>
      &efsd; uses a comprehensive set of file magic tests to determine a file's type. This set
      is stored in an XML file and loaded and interpreted when &efsd; starts. It therefore is not a
      database in the usual sense where access to a large file on disk is optimized.
    </para>
    <para>
      There's an HTML browser for the filetypes which can be used for looking up file magic
      values, offsets etc. If you're looking at an HTML version of the manual, you can go
      to the browser <ulink url="./filetypes/index.html">here</ulink>.
    </para>
  </chapter>	  

  <chapter id="summary">
    <title>Summary, TODO list</title>
    <para>
      Well, software is never finished, and this also applies to &efsd;. You can always look at the
      TODO file in CVS to see what's currently missing. Patches are appreciated, please send them
      to the author at <email>cK@whoop.org</email>. At the time of this writing, the following things
      are missing:
      
      <itemizedlist mark="opencircle">
	<listitem>
	  <para>A thorough testsuite, especially for the cache interaction and the
	    functions in <filename>efsd_fs.c</filename>, i.e. the file copy/move/remove
	    code. Ideally this would be an automated set of tests to check if changes
	    broke anything. Think XP.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    A great feature would be to not only get the filetypes in a MIME type-ish notation,
	    but also in fully human-readable form (sort of like the file(1) output). Ideally
	    this would include internationalization and localization support.
	  </para>
	</listitem>
      </itemizedlist>
      
      At the time of this writing (September 2001), &efsd; should be mostly stable. Contributions
      and patches are welcome, please send them to me at <email>cK@whoop.org</email> directly.
      I hope you'll enjoy using and programming &efsd;.

    </para>
    <para>
      Cheers, -- Christian.
    </para>
  </chapter>
  
  <bibliography>

    <biblioentry id="bib-unp">
      <bookbiblio>
	<author>	  
	  <firstname>W. R.</firstname>
	  <surname>Stevens</surname>
	</author>
	<title>UNIX Network Programming</title>
	<edition>Second Edition</edition>
	<volumenum>Volume 1</volumenum>
	<publisher>
	  <publishername>Prentice-Hall</publishername>
	</publisher>
	<date>1998</date>
      </bookbiblio>
    </biblioentry>	
      
    <biblioentry id="bib-apue">
      <bookbiblio>
	<author>
	  <firstname>W. R.</firstname>
	  <surname>Stevens</surname>
	</author>
	<title>Advanced Programming in the UNIX Environment</title>
	<publisher>
	  <publishername>Addison-Wesley</publishername>
	</publisher>
	<date>1992</date>
      </bookbiblio>
    </biblioentry>	

  </bibliography>
      
</book>

