<!-- Imlib2 Recipes -->

<chapter>
<title>Imlib2</title>

<para>
Imlib2 is the successor to Imlib. It is not just a newer version - it is a completely 
new library. Imlib2 can be installed alongside Imlib 1.x without any problems since 
they are effectively different libraries - but they Have very similar functionality.
</para>

<para>
Imlib2 can do the following:
</para>

<itemizedlist mark="bullet" spacing="compact">
 <listitem><para>Load image files from disk in one of many formats</para></listitem>
 <listitem><para>Save images to disk in one of many formats</para></listitem>
 <listitem><para>Render image data onto other images</para></listitem>
 <listitem><para>Render images to an X-Windows drawable</para></listitem>
 <listitem><para>Produce pixmaps and pixmap masks of Images</para></listitem>
 <listitem><para>Apply filters to images</para></listitem>
 <listitem><para>Rotate images</para></listitem>
 <listitem><para>Accept RGBA Data for images</para></listitem>
 <listitem><para>Scale images</para></listitem>
 <listitem><para>Alpha blend Images on other images or drawables</para></listitem>
 <listitem><para>Apply color correction and modification tables and factors to images</para></listitem>
 <listitem><para>Render images onto images with color correction and modification tables</para></listitem>
 <listitem><para>Render truetype anti-aliased text</para></listitem>
 <listitem><para>Render truetype anti-aliased text at any angle</para></listitem>
 <listitem><para>Render anti-aliased lines</para></listitem>
 <listitem><para>Render rectangles</para></listitem>
 <listitem><para>Render linear multi-colored gradients</para></listitem>
 <listitem><para>Cache data intelligently for maximum performance</para></listitem>
 <listitem><para>Allocate colors automatically</para></listitem>
 <listitem><para>Allow full control over caching and color allocation</para></listitem>
 <listitem><para>Provide highly optimized MMX assembly for core routines</para></listitem>
 <listitem><para>Provide plug-in filter interface</para></listitem>
 <listitem><para>Provide on-the-fly runtime plug-in image loading and saving interface</para></listitem>
 <listitem><para>Fastest image compositing, rendering and manipulation library for X</para></listitem>
</itemizedlist>

<para>
If what you want isn't in the list above somewhere then likely Imlib2 does not do it. 
If it does, it likely does it faster than any other library you can find (this includes 
gdk-pixbuf, gdkrgb, etc.) primarily because of highly optimized code and a smart subsystem 
that does the dirty work for you and picks up the pieces for you so you can be lazy and 
let Imlib2 do all the optimizations for you.
</para>

<para>
Imlib2 provides a powerful engine for image manipulation and rendering.  
Using loaders it can handle a variety of image formats including BMP, GIF (via unGIF),
JPEG, PNG, PNM, TGA, TIFF, XPM and more.
</para>

<section>
<sectioninfo>
  <author>
    <firstname>Ben</firstname>
    <surname>Rockwood</surname>
    <email>benr@cuddletech.com</email>
    <othername>technikolor</othername>
  </author>
  <date>6 July 2004</date>
</sectioninfo>

<title>Recipe: Image watermarking</title>


<para>
With so many individuals putting so many images online its easy to forget where they
came from and hard to ensure that copyrighted material isn't inadvertently misused.  Simply
adding a watermark image, such as your sites logo, to each of your images can solve both 
these problems.  But adding watermarks manual is a long and repetitive task.  Imlib2 can
easily be used to solve this problem.  What we need to do is take an input image,
and then specify a watermark image (your logo), position the watermark on the input image
and then save it out to a new image which we'll use on the site.  The app would look 
something like this: 
</para>

<example>
<title>Imlib2 WaterMark Program</title>
<programlisting>
#define X_DISPLAY_MISSING
#include &lt;Imlib2.h&gt;
#include &lt;stdio.h&gt;

int main(int argc, char **argv){

    Imlib_Image image_input, image_watermark, image_output;
    int     w_input, h_input;
    int     w_watermark, h_watermark;
    char    watermark[] = "watermark.png";

    if(argc &gt; 1)  {
        printf("Input image is: %s\n", argv[1]);
        printf("Watermark is: %s\n", watermark);
    }
    else {
        printf("Usage: %s input_image output_imagename\n", argv[0]);
        exit(1);
    }

    image_input = imlib_load_image(argv[1]);
    if(image_input) {
        imlib_context_set_image(image_input);
        w_input = imlib_image_get_width();
        h_input = imlib_image_get_height();
        printf("Input size is: %d by %d\n", w_input, h_input);
        image_output = imlib_clone_image();
    }

    image_watermark = imlib_load_image(watermark);
    if(image_watermark) {
        imlib_context_set_image(image_watermark);
        w_watermark = imlib_image_get_width();
        h_watermark = imlib_image_get_height();
        printf("WaterMark size is: %d by %d\n", 
		w_watermark, h_watermark);
    }

    if(image_output) {
        int dest_x, dest_y;

        dest_x = w_input - w_watermark;
        dest_y = h_input - h_watermark;
        imlib_context_set_image(image_output);

        imlib_blend_image_onto_image(image_watermark, 0, 
		0, 0, w_watermark, h_watermark, 
		dest_x, dest_y, w_watermark, h_watermark);
        imlib_save_image(argv[2]);
        printf("Wrote watermarked image to filename: %s\n", argv[2]);
    }


        return(0);
}

</programlisting>
</example>

<para>
Looking at the example, we first do some really basic argument checking, accepting an input image as the first argument
and an output image name for our watermarked copy.
Using <command>imlib_load_image()</command> we load the input image and then grab its dimensions using the get functions.
With the <command>imlib_clone_image()</command> function we can create a copy of the input image, which will be the base of our
watermarked output.  Next we load the watermark image, and notice that we then use <command>imlib_context_set_image()</command>
to change the context from the input image (image_input) to the watermark image (image_watermark).  Now we grab the images
dimensions as well.  In the final block we do two simple calculations to determine the positioning of the watermark on the
output image, in this case I want the watermark on the bottom right-hand corner.  The magic function that really does the
work in this program is <command>imlib_blend_image_onto_image()</command>.  Notice that we change context to the output
image before proceeding.  The blend function will, as the name suggests, blend two images together which we refer to
as the source and destination image.  
The blend function blends a source image onto the current image context which we designate as the destination.
The arguments supplied to 
<command>imlib_blend_image_onto_image()</command> can look tricky, we need to tell it which source to use (the watermark), 
whether to merge the alpha channel (0 for no), the dimensions of the source image (x, y, w, h) and the dimensions of the 
destination image (x, y, w, h).    You'll notice that in the example we set the x and y positions of the source (watermark)
image to 0 and then use the full width.  The destination (input image) is set to the bottom right hand corner minus
the dimensions of the watermark, and then we specify the width and height of the watermark.
Finally, we use the <command>imlib_save_image()</command> function to save the output image.
</para>

<para>
While this example should be significantly improved for real use, it outlines the basics of Imlib2 blending 
to solves a very common problem efficiently.
</para>
</section>


</chapter>

