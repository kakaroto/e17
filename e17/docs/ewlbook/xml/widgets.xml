<chapter id="ch-Widgets">
<title>Widgets</title>
<para>
We will now look at each widget individually. See the code that creates the widget and a 
screen shot of the widget in action (if applicable). 
</para>

<!-- ################################### -->
<!-- EWL BOX -->
<sect1 id="sec-EwlBox">
<title>ewl_hbox and ewl_vbox</title>

<para>
The box widgets allow you to specify different ways in which the 
application will be laid out. You can create either a horizontal (hbox)
or vertical (vbox) box. A vertical box will have its children packed
from top to bottom while a horizontal box will have its widgets
packed from left to right.
</para>

<para>
A box widget will not show up in the application itself, it is just
used as a container for other widgets.
</para>

<para>
 <example>
  <title>Creating EWL boxes</title>
  <programlisting role="C">
   Ewl_Widget *hbox = ewl_hbox_new();
   ewl_widget_show(hbox);

   Ewl_Widget *vbox = ewl_vbox_new();
   ewl_widget_show(vbox);
  </programlisting>
 </example>
The box widgets are relativly simple to create and use, only requiring a call to the
new function.
</para>

<para>
The functions to manipulate the boxes include:
<itemizedlist mark="bullet" spacing="compact">
 <listitem><para><function>void ewl_box_orientation_set(Ewl_Box *, Ewl_Orientation)</function></para></listitem>
 <listitem><para><function>Ewl_Orientation ewl_box_orientation_get(Ewl_Box *)</function></para></listitem>
 <listitem><para><function>void ewl_box_spacing_set(Ewl_Box *, int)</function></para></listitem>
 <listitem><para><function>void ewl_box_homogeneous_set(Ewl_Box *, int)</function></para></listitem>
</itemizedlist>

The <literal>Ewl_Orientation</literal> flag can be one of:
<itemizedlist mark="bullet" spacing="compact">
 <listitem><para>EWL_ORIENTATION_HORIZONTAL</para></listitem>
 <listitem><para>EWL_ORIENTATION_VERTICAL</para></listitem>
</itemizedlist>
</para>

<para>
The <function>ewl_box_spacing_set()</function> will set the amount of spacing between the
items in the box to the given value. While the <function>ewl_box_homogeneous_set()</function>
will set the box to give all items in it the same size if this is set to true, otherwise
they will have their required size.
</para>

</sect1>

<!-- ################################### -->
<!-- EWL BUTTON -->
<sect1 id="sec-EwlButton">
<title>ewl_button</title>
<para>
The button widget is simply a widget with a label attached. When the 
user clicks on the button the callback attached to 
<literal>EWL_CALLBACK_CLICKED</literal> will be executed.
</para>

<para>
 <figure>
  <title>An Ewl Button</title>
  <inlinemediaobject>
   <imageobject>
    <imagedata fileref="img/entry.png" format="png" />
   </imageobject>
   <textobject>
    <phrase>Example of an EWL entry box</phrase>
   </textobject>
  </inlinemediaobject>
 </figure>
</para>

<para>
<example id="sec-EwlButtonCode">
 <title>Creating a button</title>
 <programlisting role="C">
    Ewl_Widget *button = ewl_button_new("A button");
    ewl_object_alignment_set(EWL_OBJECT(button), EWL_FLAG_ALIGN_CENTER);
    ewl_callback_append(button, EWL_CALLBACK_CLICKED, button_cb, NULL);
    ewl_widget_show(button);
 </programlisting>
</example>
The label portion of the button can be aligned to any of the <literal>EWL_FLAG_ALIGN_*</literal>
settings.
</para>

<para>
<example id="sec-EwlButtonCB">
 <title>Button Callback</title>
 <programlisting role="C">
void button_cb(Ewl_Widget *w, void *event, void *data) {
    printf("button pressed\n");
}
 </programlisting>
</example>
</para>

<para>
The label on a button can be manipulated after the button has been created through
the two calls:
<itemizedlist mark="bullet" spacing="compact">
 <listitem><para><function>char *ewl_button_label_get(EwlButton *)</function></para></listitem>
 <listitem><para><function>void ewl_button_label_set(EwlButton *, char *)</function></para></listitem>
</itemizedlist>
</para>
</sect1>

<!-- ################################### -->
<!-- EWL CHECKBUTTON -->
<sect1 id="sec-EwlCheckButton">
<title>ewl_checkbutton</title>
<para>
 <figure>
  <title>An Ewl Checkbutton</title>
  <inlinemediaobject>
   <imageobject>
    <imagedata fileref="img/checkbutton.png" format="png" />
   </imageobject>
   <textobject>
    <phrase>Example of an EWL checkbutton</phrase>
   </textobject>
  </inlinemediaobject>
 </figure>
</para>

<para>
<example id="sec-EwlCheckButtonCode">
 <title>Creating a checkbutton</title>
 <programlisting role="C">
    Ewl_Widget *cb = ewl_checkbutton_new("Label");
    ewl_checkbutton_label_position_set(EWL_CHECKBUTTON(cb), EWL_FLAG_ALIGN_LEFT);
    ewl_callback_append(cb, EWL_CALLBACK_VALUE_CHANGED, checkbutton_cb, NULL);
    ewl_widget_show(cb);
 </programlisting>
</example>
</para>

<para>
<example id="sec-EwlCheckButtonCB">
 <title>Button Callback</title>
 <programlisting role="C">
void checkbutton_cb(Ewl_Widget *w, void *event, void *data) {
    if (ewl_checkbutton_is_checked(EWL_CHECKBUTTON(w)))
        printf("checked\n");
    else
        printf("Not checked\n");
}
 </programlisting>
</example>
</para>

</sect1>

<!-- ################################### -->
<!-- EWL COMBO -->
<sect1 id="sec-EwlCombo">
<title>ewl_combo</title>
<para>
 <figure>
  <title>An Ewl Combo box</title>
  <inlinemediaobject>
   <imageobject>
    <imagedata fileref="img/combo.png" format="png" />
   </imageobject>
   <textobject>
    <phrase>Example of an EWL combo box</phrase>
   </textobject>
  </inlinemediaobject>
 </figure>
</para>

<para>
<example id="sec-EwlComboCode">
 <title>Creating a combo box</title>
 <programlisting role="C">
    Ewl_Widget *combo = ewl_combo_new("combo box");
    ewl_callback_append(combo, EWL_CALLBACK_VALUE_CHANGED, 
                                combo_change_cb, NULL);
    ewl_widget_show(combo);

    Ewl_widget *item1 = ewl_menu_item_new(NULL, "foo");
    ewl_container_child_append(EWL_CONTAINER(combo));
    ewl_widget_show(item1);
 </programlisting>
</example>
</para>

<para>
<example id="sec-EwlComboCodeCB">
 <title>combo box value changed callback</title>
 <programlisting role="C">
void combo_change_cb(Ewl_Widget *w, void *event, void *data) {
    char *text = (char *)event;
    printf("Value changed to %s\n", text);
}
 </programlisting>
</example>
</para>

</sect1>

<!-- ################################### -->
<!-- EWL DIALOG -->
<sect1 id="sec-EwlDialog">
<title>ewl_dialog</title>
<para>
The <literal>Ewl_Dialog</literal> widget provides a way to display a simple
dialog box to the user which can then prompt for a response, give warnings
or just display simple messages.
</para>

<para>
 <figure>
  <title>An Ewl Dialog</title>
  <inlinemediaobject>
   <imageobject>
    <imagedata fileref="img/dialog_box.png" format="png" />
   </imageobject>
   <textobject>
    <phrase>Example of an EWL dialog box</phrase>
   </textobject>
  </inlinemediaobject>
 </figure>
</para>
<para>
<example id="sec-EwlDialogCode">
<title>EWL Dialog code</title>
<programlisting role="C">
    Ewl_Widget *dialog = NULL;
    Ewl_Widget *o = NULL;

    o = ewl_text_new("a dialog eh");
    ewl_object_alignment_set(EWL_OBJECT(o),
    EWL_FLAG_ALIGN_CENTER);
    ewl_widget_show(o);

    dialog = ewl_dialog_new(EWL_POSITION_BOTTOM);
    ewl_dialog_has_separator_set(EWL_DIALOG(dialog), 0);
    ewl_dialog_widget_add(EWL_DIALOG(dialog), o);
    ewl_object_alignment_set(EWL_OBJECT(dialog), EWL_FLAG_ALIGN_CENTER);
    ewl_widget_show(dialog);

    o = ewl_dialog_set_button(EWL_STOCK_OK, EWL_RESPONSE_OK);
    ewl_container_child_append(EWL_CONTAINER(dialog), o);
    ewl_callback_append(o, EWL_CALLBACK_CLICKED, dialog_clicked_cb, dialog);
    ewl_widget_show(o);

    o = ewl_dialog_set_button(EWL_STOCK_CANCEL, EWL_RESPONSE_CANCEL);
    ewl_container_child_append(EWL_CONTAINER(dialog), o);
    ewl_callback_append(o, EWL_CALLBACK_CLICKED, dialog_clicked_cb, dialog);
    ewl_widget_show(o);
</programlisting>
</example>
This example will create an <literal>Ewl_Dialog</literal> with two buttons:
an OK button and a Cancel button. The dialog itself is created with the
call to <function>ewl_dialog_new()</function> passing the position of the
buttons relative to the window itself. The possible values are:
<itemizedlist mark="bullet" spacing="compact">
 <listitem><para>EWL_POSITION_TOP</para></listitem>
 <listitem><para>EWL_POSITION_BOTTOM</para></listitem>
 <listitem><para>EWL_POSITION_LEFT</para></listitem>
 <listitem><para>EWL_POSITION_RIGHT</para></listitem>
</itemizedlist> 
</para>

<para>
A <literal>Ewl_Dialog</literal> can optionally have a horizontal line drawn
to seperate the two sections of the dialog. The line is controlled with the
<function>ewl_dialog_has_separator_set()</function> where 0 means do not
draw separator and 1 means to draw the separator. There is a corresponding
<function>ewl_dialog_has_separator_get()</function> returning 1 if there is
a separator and 0 otherwise.
</para>

<para>
The content of the main display area of the box is controlled through the
function <function>ewl_dialog_widget_add()</function>. In this instance we
add a <literal>Ewl_Text</literal> object into the dialog.
</para>

<para>
Once the dialog is initialized we need to create any desired buttons. The
buttons are created by calling <function>ewl_dialog_button_set()</function>
this will create a button. The parameters are the label of the button and
the response code to return from the button. There are several pre-defined
labels, including:
<itemizedlist mark="bullet" spacing="compact">
 <listitem><para>EWL_STOCK_OK</para></listitem>
 <listitem><para>EWL_STOCK_APPLY</para></listitem>
 <listitem><para>EWL_STOCK_CANCEL</para></listitem>
 <listitem><para>EWL_STOCK_OPEN</para></listitem>
 <listitem><para>EWL_STOCK_SAVE</para></listitem>
 <listitem><para>EWL_STOCK_PAUSE</para></listitem>
 <listitem><para>EWL_STOCK_PLAY</para></listitem>
 <listitem><para>EWL_STOCK_STOP</para></listitem>
</itemizedlist>
The pre-defined response codes are:
<itemizedlist mark="bullet" spacing="compact">
 <listitem><para>EWL_RESPONSE_OPEN</para></listitem>
 <listitem><para>EWL_RESPONSE_SAVE</para></listitem>
 <listitem><para>EWL_RESPONSE_OK</para></listitem>
 <listitem><para>EWL_RESPONSE_CANCEL</para></listitem>
 <listitem><para>EWL_RESPONSE_APPLY</para></listitem>
 <listitem><para>EWL_RESPONSE_PLAY</para></listitem>
 <listitem><para>EWL_RESPONSE_PAUSE</para></listitem>
 <listitem><para>EWL_RESPONSE_STOP</para></listitem>
</itemizedlist>
Once the buttons are created they need to be added to the dialog and have a
callback append for there <literal>EWL_CALLBACK_CLICKED</literal> state.
</para>

<para>
<example id="sec-EwlDialogCB">
<title>EWL Dialog callback</title>
<programlisting role="C">
void dialog_clicked_cb(Ewl_Widget *w, void *event, void *data) {
    int d = EWL_BUTTON_STOCK(w)->response_id;

    if (d == EWL_RESPONSE_OK)
        printf("OK\n");
    else if (d == EWL_RESPONSE_CANCEL)
        printf("CANCEL\n");

    ewl_widget_destroy(EWL_WIDGET(data));
}
</programlisting>
</example>
The response code of the button that was clicked is available from the
<literal>Ewl_Button_Stock</literal> widget itself through its response_id
parameter. Using this value we can determine which of the buttons was
clicked. We also passed the <literal>Ewl_Dialog</literal> itself through the
data parameter so that we could destroy the dialog when we were finished.
</para>
</sect1>

<!-- ################################### -->
<!-- EWL ENTRY -->
<sect1 id="sec-EwlEntry">
<title>ewl_entry</title>
<para>
The EWL entry box is available when you need to retrieve text input from the user.
The box works on single lines, and the callback is triggered when the user presses
the 'Enter' key.
</para>

<para>
 <figure>
  <title>An EWL entry box</title>
  <inlinemediaobject>
   <imageobject>
    <imagedata fileref="img/entry.png" format="png" />
   </imageobject>
   <textobject>
    <phrase>Example of an EWL entry box</phrase>
   </textobject>
  </inlinemediaobject>
 </figure>
</para>

<para>
 <example>
  <title>Creating an EWL entry box</title>
  <programlisting role="C">
   Ewl_Widget *entry = ewl_entry_new();
   ewl_object_size_request(EWL_OBJECT(entry), 100, 15);
   ewl_object_padding_set(EWL_OBJECT(entry), 1, 1, 1, 1);
   ewl_callback_append(entry, EWL_CALLBACK_VALUE_CHANGED, entry_cb, NULL);
   ewl_widget_show(entry);
  </programlisting>
 </example> 
The <literal>Ewl_Entry</literal> is a fairly simple object to work with, about the
only required setup is to create the new object and attach a callback for
<literal>EWL_CALLBACK_VALUE_CHANGED</literal> events. This example takes the 
extra steps of setting the size with <function>ewl_object_size_request()</function>
and adding a little bit of padding to the widget with 
<function>ewl_object_padding_set()</function>.
</para>

<para>
 <example>
  <title>Ewl_Entry value changed callback</title>
  <programlisting role="C">
void entry_cb(Ewl_Widget *w, void *event, void *data) {
    char *s = ewl_entry_get_text(EWL_ENTRY(w));
    printf("%s\n", s);

    ewl_entry_set_text(EWL_ENTRY(w), "New Text");
}
  </programlisting>
 </example>
This callback grabs the current value of the entry widget with the call to
<function>ewl_entry_get_text()</function> and then resets the text to the 
value of 'New Text' by calling <function>ewl_entry_set_text()</function>.
</para>

<para>
The <literal>Ewl_Entry</literal> object allows you to set whether or not the
text is editable with a call to 
<function>void ewl_entry_set_editable(Ewl_Entry *, unsigned int edit)</function>
where <literal>edit</literal> is 0 for uneditable and editable otherwise.
</para>
</sect1>

<!-- ################################### -->
<!-- EWL FILEDIALOG -->
<sect1 id="sec-EwlFileDialog">
<title>ewl_filedialog</title>
<para>
It is often desired to allow the user to open and save files. This can
be easily accomplished through the use of the <literal>Ewl_Filedialog</literal>.
</para>
<para>
 <figure>
  <title>An EWL file dialog</title>
  <inlinemediaobject>
   <imageobject>
    <imagedata fileref="img/file_dialog.png" format="png" />
   </imageobject>
   <textobject>
    <phrase>Example of an EWL file dialog</phrase>
   </textobject>
  </inlinemediaobject>
 </figure>
This file dialog has been embedded into its own window, but it could have been
placed in another window in the same fashion.
</para>

<para>
 <example>
  <title>Creating an EWL filedialog</title>
  <programlisting role="C">
   Ewl_Widget *filedialog = ewl_filedialog_new(EWL_FILEDIALOG_TYPE_OPEN);
   ewl_callback_append(filedialog, EWL_CALLBACK_VALUE_CHANGED, 
                            open_file_cb, NULL);
   ewl_widget_show(filedialog);
  </programlisting>
 </example>
When the file dialog is created you specify a type either 
<literal>EWL_FILDIALOG_TYPE_OPEN</literal> or <literal>EWL_FILEDIALOG_TYPE_SAVE</literal>
depending on the type of file dialog desired. The callback 
<literal>EWL_CALLBACK_VALUE_CHANGED</literal> will be executed when the user clicks
the 'Open' button in the dialog.
</para>

<para>
It is also possible to pack other widgets into the filedialog itself. This is done through
the normal <function>ewl_container_child_append()</function>. So, if you 
needed, for example, to add a 'Home' button, you could create the button and pack it 
into the file dialog where it will appear down the left side.
</para>

<para>
You can change the directory that is currently being viewed in the file dialog by
executing <function>void ewl_filedialog_set_directory(Ewl_Filedialog *, char *path)</function>
where <literal>path</literal> is the full path to the desired directory.
</para>

<para>
 <example>
  <title>Ewl_Filedialog open callback</title>
  <programlisting role="C">
void open_file_cb(Ewl_Widget *w, void *event, void *data) {
    char *filename = (char *)event;
    printf("selected file %s\n", filename);
}
  </programlisting>
 </example>
The file that has been selected is passed to the callback as the <literal>event</literal>
parameter. If you wish to remove the filedialog you can do something similar to 
<literal>ewl_widget_hide(fd_win)</literal> where <literal>fd_win</literal> is the window
object holding the file dialog.
</para>
</sect1>

<!-- ################################### -->
<!-- EWL IMAGE -->
<sect1 id="sec-EwlImage">
<title>ewl_image</title>
<para>
<example>
<title>Ewl_Image</title>
<programlisting>
    Ewl_Widget *i = ewl_image_new("/usr/foo/img.png", NULL);
    ewl_widget_show(i);
</programlisting>
</example>
The <function>ewl_image_new()</function> function takes two parameters, the
path to the image to be loaded and a key for the image data. The key is used
primarily to load edje groups or keyed data as the image.
</para>

</sect1>

<!-- ################################### -->
<!-- EWL MENU -->
<sect1 id="sec-EwlMenu">
<title>ewl_menu</title>
<para>
</para>
</sect1>

<!-- ################################### -->
<!-- EWL NOTEBOOK -->
<sect1 id="sec-EwlNotebook">
<title>ewl_notebook</title>
<para>
 <figure>
  <title>An EWL Notebook</title>
  <inlinemediaobject>
   <imageobject>
    <imagedata fileref="img/notebook.png" format="png" />
   </imageobject>
   <textobject>
    <phrase>Example of an EWL Notebook</phrase>
   </textobject>
  </inlinemediaobject>
 </figure>
</para>
<para>
</para>
</sect1>

<!-- ################################### -->
<!-- EWL PASSWORD -->
<sect1 id="sec-EwlPassword">
<title>ewl_password</title>
<para>
The <literal>Ewl_Password</literal> widget provides similar functionality to
the <literal>Ewl_Text</literal> widget, except that any text entered will
not be displayed, instead a configurable obscuring character will be
displayed.
</para>

<para>
 <figure>
  <title>An EWL password dialog</title>
  <inlinemediaobject>
   <imageobject>
    <imagedata fileref="img/passwd.png" format="png" />
   </imageobject>
   <textobject>
    <phrase>Example of an EWL password dialog</phrase>
   </textobject>
  </inlinemediaobject>
 </figure>
</para>

<para>
<example>
<title>Creating an EWL password</title>
<programlisting role="C">
    Ewl_Widget *p = ewl_password_new("default");
    ewl_password_obscure_set(EWL_PASSWORD(p), "-");
    ewl_callback_append(p, EWL_CALLBACK_VALUE_CHANGED, passwd_cb, NULL);
    ewl_widget_show(p);
</programlisting>
</example>
The default obscuring character used is a '*' character. This can be easily
changed by calling 
<function>ewl_password_obscure_set(Ewl_Password *, char)</function>.
There is also a corresponding 
<function>char ewl_password_obscure_get(Ewl_Password *)</function> to
retrieve the current obscuring character. As with the
<literal>ewl_text</literal> widget there are two functions to get and set
the text of the widget: 
<function>ewl_password_text_set(Ewl_Password *, char *)</function> and
<function>char *ewl_password_text_get(Ewl_Password *)</function>.
</para>

<para>
When the user presses the enter key in the password box a
<literal>EWL_CALLBACK_VALUE_CHANGED</literal> will be triggered.
<example>
<title>Ewl_Password value changed callback</title>
<programlisting role="C">
void passwd_cb(Ewl_Widget *, void *event, void *data) {
    char *text = ewl_password_text_get(EWL_PASSWORD(w));
    printf("text: %s\n", text);
}
</programlisting>
</example>
</para>
</sect1>

<!-- ################################### -->
<!-- EWL PROGRESSBAR -->
<sect1 id="sec-EwlProgressBar">
<title>ewl_progressbar</title>
<para>
 <figure>
  <title>An EWL progress bar</title>
  <inlinemediaobject>
   <imageobject>
    <imagedata fileref="img/progressbar.png" format="png" />
   </imageobject>
   <textobject>
    <phrase>Example of an EWL progress bar</phrase>
   </textobject>
  </inlinemediaobject>
 </figure>
</para>
<para>
</para>
</sect1>

<!-- ################################### -->
<!-- EWL RADIO BUTTON -->
<sect1 id="sec-Ewl-RadioButton">
<title>ewl_radiobutton</title>
<para>
 <figure>
  <title>An EWL radiobutton</title>
  <inlinemediaobject>
   <imageobject>
    <imagedata fileref="img/radiobutton.png" format="png" />
   </imageobject>
   <textobject>
    <phrase>Example of an EWL radiobutton</phrase>
   </textobject>
  </inlinemediaobject>
 </figure>
</para>
<para>
</para>
</sect1>

<!-- ################################### -->
<!-- EWL SCROLLPANE -->
<sect1 id="sec-EwlScrollpane">
<title>ewl_scrollpane</title>
<para>
</para>
</sect1>

<!-- ################################### -->
<!-- EWL SEEKER -->
<sect1 id="sec-EwlSeeker">
<title>ewl_seeker</title>
<para>
 <figure>
  <title>An EWL seeker</title>
  <inlinemediaobject>
   <imageobject>
    <imagedata fileref="img/seeker.png" format="png" />
   </imageobject>
   <textobject>
    <phrase>Example of an EWL seeker</phrase>
   </textobject>
  </inlinemediaobject>
 </figure>
</para>
<para>
<example>
<title>Creating an EWL seeker</title>
<programlisting role="C">
    Ewl_Widget *s = ewl_seeker_new(EWL_ORIENTATION_HORIZONTAL);
    ewl_seeker_value_set(EWL_SEEKER(s), 5.0);
    ewl_seeker_range_set(EWL_SEEKER(s), 10.0);
    ewl_seeker_step_set(EWL_SEEKER(s), 1);
    ewl_callback_append(s, EWL_CALLBACK_VALUE_CHANGED, seeker_cb, NULL);
    ewl_widget_show(s);
</programlisting>
</example>
</para>

<para>
<example>
<title>Ewl_Seeker callback</title>
<programlisting role="C">
void seeker_cb(Ewl_Widget *w, void *event, void *data) {
    double val = ewl_seeker_value_get(EWL_SEEKER(w));
    printf("%f\n", val);
}
</programlisting>
</example>
</para>

</sect1>

<!-- ################################### -->
<!-- EWL SPINNER -->
<sect1 id="sec-EwlSpinner">
<title>ewl_spinner</title>
<para>
 <figure>
  <title>An EWL spinner</title>
  <inlinemediaobject>
   <imageobject>
    <imagedata fileref="img/spinner.png" format="png" />
   </imageobject>
   <textobject>
    <phrase>Example of an EWL spinner</phrase>
   </textobject>
  </inlinemediaobject>
 </figure>
</para>
<para>
</para>
</sect1>

<!-- ################################### -->
<!-- EWL TABLE -->
<sect1 id="sec-EwlTable">
<title>ewl_table</title>
<para>
</para>
</sect1>

<!-- ################################### -->
<!-- EWL TEXT -->
<sect1 id="sec-EwlText">
<title>ewl_text</title>
<para>
The <literal>Ewl_Text</literal> widget provides for a multi-line text layout
widget. It can be utillized whenever the display of text is required in an
application. It works well with the <literal>Ewl_Scrollpane</literal> to
provide a scrollable text area.
</para>
<para>
<example id="sec-EwlTextCode">
<title>Ewl_Text code</title>
<programlisting role="C">
    Ewl_Widget *text = ewl_text_new("text");
    ewl_widget_show(text);
</programlisting>
</example>
Creating the basic <literal>Ewl_Text</literal> object is pretty simple, the
object will be setup to diplay the parameter to
<function>ewl_text_new()</function>.
</para>

<para>
Once the text object is created you can change the text, retrieve the
current text contents or get the text length with:
<itemizedlist mark="bullet" spacing="compact">
 <listitem><para><function>ewl_text_text_set(Ewl_Text *, char *)</function></para></listitem>
 <listitem><para><function>ewl_text_text_prepend(Ewl_Text *, char *)</function></para></listitem>
 <listitem><para><function>ewl_text_text_append(Ewl_Text *, char *)</function></para></listitem>
 <listitem><para><function>ewl_text_text_insert(Ewl_Text *, char *, int index)</function></para></listitem>
 <listitem><para><function>char *ewl_text_text_get(Ewl_Text *)</function></para></listitem>
 <listitem><para><function>int ewl_text_length_get(Ewl_Text *)</function></para></listitem>
</itemizedlist>
</para>

<para>
The <literal>Ewl_Text</literal> widget allows you to preform styling changes
to the text in the widget. Different portions of the text can be different
colours, fonts or styles. The styling that is applied to a widget is based
on what is setup when the text is added to the widget. So, if you want your
text to be red, you need to set the colour of the
<literal>Ewl_Text</literal> object <emphasis>before</emphasis> adding the
text.
</para>

<para>
The colour of the text can be manipulated with the
<function>ewl_text_color_set(Ewl_Text *, int r, int g, int b, int a)</function>
call while the current colour information can be retrieved with the
<function>ewl_text_color_get(Ewl_Text *, int *r, int *g, int *b, int *a)</function>.
</para>

<para>
The font settings of the text can be manipulated with the
<function>ewl_text_font_set(Ewl_Text *, char *font, int size)</function>
call. With the calls to get the current font name as size defined as:
<function>char *ewl_text_font_get(Ewl_Text *)</function> and
<function>int ewl_text_font_size_get(Ewl_Text *)</function>.
</para>

<para>
To retrieve or set the alignment of the text widget there are the two
functions: <function>ewl_text_align_set(Ewl_Text *, unsigned int align)</function>
and <function>unsigned int ewl_text_align_get(Ewl_Text *)</function>. Where
the align parameter is one of the EWL alignment flags:
<itemizedlist mark="bullet" spacing="compact">
 <listitem><para>EWL_FLAG_ALIGN_CENTER</para></listitem>
 <listitem><para>EWL_FLAG_ALIGN_LEFT</para></listitem>
 <listitem><para>EWL_FLAG_ALIGN_RIGHT</para></listitem>
 <listitem><para>EWL_FLAG_ALIGN_TOP</para></listitem>
 <listitem><para>EWL_FLAG_ALIGN_BOTTOM</para></listitem>
</itemizedlist>
</para>

<para>
It is also possible to set the style of the text. This can include things
such as bolding the text or setting soft shadows. The styles that are
available are shipped through the Etox library and currently include:
<itemizedlist mark="bullet" spacing="compact">
 <listitem><para>bold</para></listitem>
 <listitem><para>outline</para></listitem>
 <listitem><para>plain</para></listitem>
 <listitem><para>raised</para></listitem>
 <listitem><para>shadow</para></listitem>
 <listitem><para>soft_shadow</para></listitem>
</itemizedlist>
</para>
</sect1>

<!-- ################################### -->
<!-- EWL TOOLTIP -->
<sect1 id="sec-EwlTooltip">
<title>ewl_tooltip</title>
<para>
 <figure>
  <title>An EWL tooltip</title>
  <inlinemediaobject>
   <imageobject>
    <imagedata fileref="img/tooltip.png" format="png" />
   </imageobject>
   <textobject>
    <phrase>Example of an EWL tooltip</phrase>
   </textobject>
  </inlinemediaobject>
 </figure>
</para>
<para>
</para>
</sect1>

<!-- ################################### -->
<!-- EWL TREE -->
<sect1 id="sec-EwlTree">
<title>ewl_tree</title>
<para>
</para>
</sect1>

<!-- ################################### -->
<!-- EWL MEDIA -->
<sect1 id="sec-EwlMedia">
<title>ewl_media</title>
<para>
The <literal>Ewl_Media</literal> widget allows for the embedding of video
objects into your application. This is done by wrapping around the Emotion
library.
</para>

<para>
 <figure>
  <title>An EWL media object</title>
  <inlinemediaobject>
   <imageobject>
    <imagedata fileref="img/ewl_media.png" format="png" />
   </imageobject>
   <textobject>
    <phrase>Example of an EWL Media object</phrase>
   </textobject>
  </inlinemediaobject>
 </figure>
</para>

<para>
<example id="sec-EwlMediaCode">
<title>Ewl_Media code</title>
<programlisting role="C">
    Ewl_Media *m = ewl_media_new(file);
    ewl_callback_append(m, EWL_CALLBACK_REALIZE, video_realize_cb, NULL);
    ewl_callback_append(m, EWL_CALLBACK_VALUE_CHANGED, video_change_cb, NULL);
    ewl_widget_show(m);
</programlisting>
</example>
Creating the basic video object is no harder then creating the object and
showing it (assuming you've appended it to whatever container it is being
placed into). We hook the two callbacks
<literal>EWL_CALLBACK_REALIZE</literal> and
<literal>EWL_CALLBACK_VALUE_CHANGED</literal>. We hook in the realize
callback so we can determine the length of the video to be displayed if
desired. This is only available after the video has been realized, and will
return 0 until it has been realized. The value change callback will be
called whenever emotion advances the video. This can be used to setup a
timer, or a seek bar and have it auto advance for the video.
</para>

<para>
<example>
 <title>Ewl_Media callbacks</title>
 <programlisting role="C">
void video_realize_cb(Ewl_Widget *w, void *event, void *data) {
    double len = ewl_media_length_get(EWL_MEDIA(video));
}   

void video_change_cb(Ewl_Widget *w, void *event, void *data) {
    char buf[512];
    int h, m;
    double s;
                
    ewl_media_position_time_get(EWL_MEDIA(video), &amp;h, &amp;m, &amp;s);
    snprintf(buf, sizeof(buf), "%02i:%02i:%02.0f", h, m, s);
}
 </programlisting>
</example>
</para>

<para>
The video that is being displayed can be changed by calling
<function>ewl_media_media_set(Ewl_Media *, char *)</function> or if you just
wish to know what is currently playing you can call
<function>char *ewl_media_media_get(Ewl_Media *)</function>. The length of
the current video can be retrieved by calling <function>int
ewl_media_length_get(Ewl_Media *)</function>. The length can also be
retrieved as a time value by calling
<function>ewl_media_length_time_get(Ewl_Media *, int h, int m, double s)</function>.
</para>

<para>
You can start the video playing by passing 1 to
<function>ewl_media_play_set(Ewl_Media *, int)</function> or stop the video
by passing 0 to the same function.
</para>

<para>
To determine if the video codec allows for seeking in the video you can call
<function>int ewl_media_seekable_get(Ewl_Media *)</function> which will
return 1 if the video is seekable, 0 otherwise.
<function>double ewl_media_position_get(Ewl_Media *)</function> is used to determine
the current position in the video, while
<function>ewl_media_position_set(Ewl_Media *, double position)</function>
can be used to set the position in the video. This value can also be
retrieved as a hours, minutes and seconds by calling
<function>ewl_media_position_time_get(Ewl_Media *, int h, int m, double s)</function>.
</para>

<para>
If you wish to change the audio settings of the video there are several
functions available. These including the ability to get/set the current mute
settings: <function>int ewl_media_audio_mute_get(Ewl_Media *)</function> and
<function>ewl_media_audio_mute_set(Ewl_Media *, int)</function>. You can
also get/set the volume of the video through the calls:
<function>int ewl_media_audio_volume_get(Ewl_Media *)</function> and
<function>ewl_media_audio_volume_set(Ewl_Media *, int)</function>.
</para>
</sect1>

<!-- ################################### -->
<!-- EWL WINDOW -->
<sect1 id="sec-EwlWindow">
<title>ewl_window</title>
<para>
An ewl_window will be used by every EWL application. This is the window that
will display all of the other desired EWL widgets.
</para>

<para>
 <figure>
  <title>An EWL Window</title>
  <inlinemediaobject>
   <imageobject>
    <imagedata fileref="img/create_window.png" format="png" />
   </imageobject>
   <textobject>
    <phrase>Example of an EWL window</phrase>
   </textobject>
  </inlinemediaobject>
 </figure>
</para>

<para>
 <example id="sec-EwlWindowCode">
  <title>Creating a Window</title>
  <programlisting role="C">
    Ewl_Widget *window = ewl_window_new();
    ewl_window_title_set(EWL_WINDOW(window), "foo window");
    ewl_window_class_set(EWL_WINDOW(window), "foo_class");
    ewl_window_name_set(EWL_WINDOW(window), "foo_name");
    ewl_object_size_request(EWL_OBJECT(window), 300, 400);
    ewl_callback_append(window, EWL_CALLBACK_DELETE_WINDOW, win_del_cb, NULL);
    ewl_widget_show(window);
  </programlisting>
 </example>
Setting up the basic window is pretty simple. We take the extra steps of
calling: <function>ewl_window_title_set()</function>, 
<function>ewl_window_name_set()</function> and <function>ewl_window_class_set()</function>
to fill in the information the window manager uses.
</para>

<para>
Since the window is a <literal>Ewl_Object</literal> like any other, we use the
<function>ewl_object_size_request()</function> to request the starting size of
our window. We could have also called <function>ewl_object_minimum_size_set()</function>
and <function>ewl_object_maximum_size_set()</function> to constrain the 
minimum/maximum sizes of our window.
</para>

<para>
The main callback used by a Ewl_Window is the <literal>EWL_CALLBACK_DELETE_WINDOW</literal>.
This will be called when the window is being destroyed by the 
window manager. It should be used to cleanup any resources that the application has
used before exiting the application.
</para>

<para>
 <example id="sec-EwlWindowDestroyCb">
 <title>Ewl Window destroy callback</title>
 <programlisting role="C">
void win_del_cb(Ewl_Widget *w, void *event, void *data) {
    ewl_widget_destroy(w);
    ewl_main_quit();
}
 </programlisting>
 </example>
</para>

<para>
Some of the other operations involving the Ewl_Window object are:
<itemizedlist mark="bullet" spacing="compact">
 <listitem><para><function>char *ewl_window_title_get(Ewl_Window *)</function></para></listitem>
 <listitem><para><function>char *ewl_window_name_get(Ewl_Window *)</function></para></listitem>
 <listitem><para><function>char *ewl_window_class_get(Ewl_Window *)</function></para></listitem>
 <listitem><para><function>void ewl_window_borderless_set(Ewl_Window *)</function></para></listitem>
 <listitem><para><function>void ewl_window_move(Ewl_Window *, int x, int y)</function></para></listitem>
 <listitem><para>
  <function>void ewl_window_position_get(Ewl_Window *, int *x, int *y)</function>
 </para></listitem>
</itemizedlist>
The first three calls are pretty self explanatory. The <function>ewl_window_borderless_set()</function>
can be used to tell the window manager not to display any decoration around the window, this includes
the border and the title bar. The function <function>ewl_window_move()</function> is used to
position the window to a specific place on the desktop, indexed from the top
left corner. There is also a <function>ewl_window_position_get()</function> which will return the position 
of the window on the desktop.
</para>
</sect1>

</chapter>


