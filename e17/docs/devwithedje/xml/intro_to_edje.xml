<chapter>
    <title>Introduction to Edje</title>

    <para>Allow me to quote the introduction of the Edje API Reference for a
          moment. After all, I cannot expect to give Edje a better introduction
          than its creator:
          <blockquote>
              <para>Edje is a complex graphical design and layout library. [..]</para>
              
              <para>[..] Edje should serve all the purposes of creating visual
                    elements (borders of windows, scrollbars, etc.) and allow
                    the designer the ability to animate, layout and control the
                    look and feel of any program using Edje as its basic GUI
                    constructor. This library allows for multiple collections
                    of Layouts in one file, sharing the same image database and
                    thus allowing a whole theme to be conveniently packaged
                    into 1 file and shipped around.</para>

              <para>Edje [..] separates the layout and behavior logic. Edje
                    files ship with an image database, used by all the parts
                    in all the collections to source graphical data. [..]
                    Each part collection consists of a list of visual parts,
                    as well as a list of programs. A program is a
                    conditionally run program that if a particular event
                    occurs (a button is pressed, a mouse enters or leaves a
                    part) will trigger an action that may affect other parts.
                    In this way a part collection can be "programmed" via its
                    file as to hilight buttons when the mouse passes over
                    them or show hidden parts when a button is clicked
                    somewhere etc. The actions performed in changing from one
                    state to another are also allowed to transition over a
                    period of time, allowing animation.</para>

              <para>[..] This separation and simplistic event driven style of
                    programming can produce almost any look and feel one could
                    want for basic visual elements. Anything more complex is
                    likely the domain of an application or widget set that may
                    use Edje as a convenient way of being able to configure
                    parts of the display.</para>
          </blockquote>
    </para>

    <para>As we have seen in the past chapters, there are two main methods for
          creating Graphical User Interfaces. In both cases it had to be
          implemented through a programming API. In one case, the API was used
          by the application developer to assemble interface objects from more
          primitive objects, in the other case the API was used to include
          objects already defined by a library. Any changes to an interface
          object beyond simplistic style modifications had to be submitted by
          the designer to the developer. Layout changes were only slightly less
          difficult than behavior changes. The idea of working on the interface
          objects and their composition in a live environment, like a web
          developer does, was pretty much unthinkable.</para>
      
    <para>This is where the Edje library fits in, it liberates the designer and
          the developer from eachother. The artists uses the Edje Data
          Collection language to manipulate the primitive Evas objects. EDC is
          in some ways comparable to Cascading Style Sheets but free of the
          framework that markup imposes. On the other side, the developer only
          has to include the resulting object and setup the callbacks to the
          application code.</para>

    <figure>
          <title>Edje Workflow</title>
          <mediaobject><imageobject>
              <imagedata fileref="img/workflow.png" format="png" ScaleFit="1" width="100%"></imagedata>
          </imageobject></mediaobject>
    </figure>
    
    <para>Except for the usage of nested blocks, the sintax of an EDC file is
          similar to CSS. What really sets them appart is that with EDC the
          designer it's free to create and layout design elements as he sees
          fit. With CSS the designer is limited to applying style and layout
          properties to objects in a structure defined by the markup. In Edje
          each design object is referred to as "part" and the final interface
          object composed by those parts is referred to as "group". The
          resulting theme file can consist of multiple groups representing each
          final interface object.</para>

    <para>The application developer will find out that the Edje API is small,
          since the developer is not expected to alter the composition of a
          group. The API focus on high level manipulation of groups, like
          forcing a maximum size, but provides some functions to alter the
          content of a part when it's necessary to transmit information, like
          altering a paragraph of text with a message.</para>

    <para>Comparing Edje to both extremes of GUI development we can see it
          provides the flexibility of developing your own interface objects
          from a plain canvas, yet remain almost as simple as including a
          predefined object from a toolkit. Of course Edje has shortcomings of
          its own and we will explore them in this book as well.</para>

    <section>
        <title>The foundations.</title>

        <para>From a developer's point of view, we cannot expect to understand
              how Edje works without going through a brief introduction about
              the Evas first. Luckily for this writer, an excellent introduction
              to Evas has already been written in the API Reference:
              <blockquote>
                  <para>Evas is a clean display canvas API for several target
                        display systems that can draw anti-aliased text, smooth
                        super and sub-sampled scaled images, alpha-blend
                        objects much and more.</para>
                      
                  <para>It abstracts any need to know much about what the
                        characteristics of your display system are or what
                        graphics calls are used to draw them and how. It deals
                        on an object level where all you do is create and
                        manipulate objects in a canvas, set their properties,
                        and the rest is done for you.</para>
                      
                  <para>Evas optimises the rendering pipeline to minimise
                        effort in redrawing changes made to the canvas and so
                        takes this work out of the programmers hand, saving a
                        lot of time and energy.</para>
                      
                  <para>It's small and lean, designed to work on embedded
                        systems all the way to large and powerful multi-cpu
                        workstations. It can be compiled to only have the
                        features you need for your target platform if you so
                        wish, thus keeping it small and lean. It has several
                        display back-ends, letting it display on several
                        display systems, making it portable for cross-device
                        and cross-platform development.</para>
             </blockquote>
        </para>

        <para>When using the Evas API directly, the developer uses function
              calls like "evas_object_line_add" and "evas_object_image_add" to
              include the different primitives in our canvas. Each of these
              primitives would be included in the form of an "Evas object".</para>

        <para>But Evas is not limited to simply rendering primitive objects.
              The most common use for a canvas is to assemble multiple
              primitives like lines or rectangles into figures like charts or
              diagrams. In order to maintain coherency among all the primitives
              the developer was forced to implement functions that abstracted
              manipulation of the figure from the manipulation of its
              components. One of these "workarounds" is now known as Evas Smart
              Objects.</para>
              
        <para>Smart objects are implemented by the developer to create new Evas
              object types. Functions like add, del, hide, show are implemented
              using the regular Evas API to affect each primitive. This
              collection of functions is grouped into a new Evas Smart Class
              structure that consist of a list of pointers to the functions,
              the object type name and version. The instances resulting from
              these classes would be manipulated by the canvas in the same
              way it does for any other object.</para>

        <para>Edje is implemented as a more abstract type of smart object. The
              list of primitives to manipulate is not hard coded into the
              functions forming the Smart Class. Edje has functions that
              analyze the structure of a compiled theme file and get the list
              of primitives and their properties from a given "group" inside
              the file.</para>

        <para>In the end Edje interfaces can be seen as an illustration over a
              canvas. Space they can share with other primitive and smart
              objects. Without an Evas canvas there is no Edje theme.</para>
          
    </section>

    <section>
        <title>Convenient libraries.</title>

        <para>The normal process to get a canvas up and running can be
              bothersome. Evas supports multiple rendering engines, like the
              software, xrender and opengl flavors of X11 and framebuffer
              devices. But before any rendering can be done the developer has
              to complete an Evas_Engine_Info structure with the required
              information about the target engine. This forces the developer to
              research the different functions to get that information for each
              target. Alternatively he can use a shortcut available for most
              of them.</para>

        <para>As you might have realized by at this point, I intend to quote
              the official API reference at every chance I get. This one comes
              straight from the "The Ecore Main Loop" page:
              <blockquote>
                  <para>Ecore is a clean and tiny event loop library with many
                        modules to do lots of convenient things for a
                        programmer, to save time and effort.</para>

                  <para>It's small and lean, designed to work on embedded
                        systems all the way to large and powerful multi-cpu
                        workstations. It serializes all system signals,
                        events etc. into a single event queue, that is easily
                        processed without needing to worry about concurrency.
                        A properly written, event-driven program using this
                        kind of programming doesn't need threads, nor has to
                        worry about concurrency. It turns a program into a
                        state machine, and makes it very robust and easy to
                        follow.</para>
                </blockquote>
        </para>
                
        <para>At the beginning of its life, the Ecore library was used as a
              Event loop and loop management is still one of the modules
              that composes Ecore.</para>

        <figure>
              <title>The necessary libraries</title>
              <mediaobject><imageobject>
                      <imagedata fileref="img/required_libraries.png" format="png" ScaleFit="1" width="100%"></imagedata>
                  </imageobject></mediaobject>
        </figure>  
          
        <para>Today, Ecore encompasses a long list of modules namespaced with
              the Ecore_Modulename_ prefix. From what we have seen in the
              previous chapters, there are two modules that jump right out of
              the list. The first Ecore_Evas and second named Ecore. The first
              provides convenient functions to setup the Evas canvas and the
              later provides the loop management functionality described above.</para>

        <para>The developer needs an Evas canvas to render the Edje interface
              and Ecore_Evas is the simplest way to get an Evas canvas up and
              running. This wrapper is intended to support every backend that
              Evas supports with its respective (and sometimes unique)
              attributes. It trivializes initialization to a couple of lines
              and multiple engine support to an application reload.</para>
        
    </section>

</chapter>